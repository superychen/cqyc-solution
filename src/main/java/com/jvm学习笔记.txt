AVL树：需要平衡的二叉搜索树，除了二叉树的左右大小外，每个叶子节点相差的高度不得大于1
伸展树：o(MlogN),在搜索到最底层之后，进行单旋转或者双旋转，使树慢慢平衡，这样在总体时间内能保证在O(MlogN)算法内
bash configure --enable-debug --with-jvm-variants=server

make images


make clean 
make dist-clean


java虚拟机：

运行时数据区：私有（程序计数器，虚拟机栈，本地方法栈）公共（方法区（有可能是Metaspace）、堆）
	堆分年轻代和老年代，年轻代分为Eden（对象首次创建时放入的区域，进行垃圾回收后，不能回收的放入survivor区）、
	from survivor、to survivor（这两个空间一样大，始终保持一个为空的，to survivor是存不能被回收的对象。
	from 中垃圾收集后，把不被回收对象转到to survivor，然后标记转换，即to改为from，from改为to，始终保持一个为空的）

指针碰撞：serial、parnew
空闲列表：cms

分配内存时指针如何保证现成安全，一种是利用cas配上失败重试保证更新的原子性。二是每个线程预先分配一小块内存，俗称本地线程缓冲，通过参数-XX：+/-UserTLAB设定

初始化好之后，进行必要设置，如哪个类的实例，如何找到类的元数据信息，对象的哈希码，GC分代年龄信息等存在对象头里面。

对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
对象头分两类，一类是对象本身运行时数据，如哈希码，gc分代年龄，锁状态，另一类就是指针，指向元数据的指针。
实例数据就是存储的具体对象字段数据，按long、int、short来划分。对齐填充没啥用，就是为了保证数据是8字节的整数倍

对象访问定位方式氛围两种：第一种是句柄池定位，第二种是直接指针访问，句柄池定位会在栈上记录堆中的句柄池对象地址，然后在堆中的句柄池
	记录对象数据地址和方法区中的类型地址。第二种就直接把数据存在堆中，然后记录类型地址，少一步。句柄池好处就是当垃圾回收时对象移动时，只改变指针地址。

java内存溢出：
-XX：+HeapDumpOnOutOf-MemoryError: 可以发生oom时dump出内存快照。
栈容量由参数 -Xss设定

内存溢出主要是示例：git@github.com:superychen/cqyc-solution.git

3、垃圾收集器与内存分配策略	

堆中如何确定对象已死？：引用计数法：简单明了，无法解决对象循环引用问题，Java未考虑使用。参考示例ReferenceCountingGC类。
	可达性分析算法：通过一系列GC Roots根对象，根据引用对象向下搜索，如果某个GC Roots没有任何引用链相连，就证明此对象不可用。比如虚拟机栈中的引用对象，
静态变量、常量池、还有同步锁中对象
	引用的集中分类：强（gc roots链引用任何情况都不断）、软（在要内存溢出的时候回收）、弱（只要垃圾扫描到，都会被回收）、
				虚（根本拿不到对象，只能用来在被回收时进行一次系统通知回调）
	finalize方法：其实就是给对象重活一次的机会，在第一次系统回收时，先打上被回收的标记，如果有finalize方法，会执行第二次，在finalize方法
				里面执行是否复活。因为这个有很强的不确定性，无法保证对象的调用顺序。请忽略这个方法。
	
4、垃圾回收算法
	可分为直接回收（引用计数式垃圾）和间接回收（追踪式垃圾）两大类（大部分为间接回收）
	4.1 分代收集理论（年轻代/老年代）：
		弱分代假说：对象都是朝生夕灭
		强分代假说：熬过多次垃圾回收就越难消亡（会到老年区）
		--- 跨代引用假说：相对于同代引用占极少数
		在java堆中划分出来的不同的区域，垃圾收集器可以每次只回收其中一个区域的，因此在年轻代中有（Minor GC/Young GC）说法
		老年代中有（Major GC/Old GC）的说法, 对于full gc：收集整个java堆和方法区的垃圾收集
		
	4.2: 标记-清除算法
		标记（被可达性分析gc roots判断是否有引用）需要回收的对象，完成后统一回收。
		缺点：1、效率不稳定（如果大量需要回收，就要大量标记清除）2、内存空间的碎片化（清除后会产生大量的不连续内存碎片，
					内存碎片太多会导致分配大对象时无法找到足够大的连续内存，从而再次触发垃圾回收）
	
	4.3: 标记-复制算法（上一个的改良版，为解决大量可回收对象执行效率低的问题）
		半区复制，将可用内存分为两块，一块用完后将存活的复制到另外空的一块上，然后已使用的一块清除掉。
			（会用到大量的内存空间复制开销，适用于多数对象都是可回收的情况。）
		缺点：内存缩小一半，空间浪费
			目前商用虚拟机优先采用的就是这种算法，因为正常情况下新生代对象98%熬不过第一轮回收。所以hotspot使用了一种appel式回收。
			（其实就是一块eden区和两块survivor区，比例为8:1:1，90%是不空闲的，一块survivor区总是空闲的，发生垃圾回收时，eden区
			和一块survivor区将存活的对象一次性复制到空闲的survivor区中，如果空间不足，进行分配担保，将对象转移至老年代）
		
	4.4：标记-整理算法（老年代使用，针对大部分对象存活的情况）
		标记清除的移动版本，就是标记了之后不清理，让存活的对象想内存空间的另一端移动，完成后直接清理边界以外的内存即可。
		缺点：移动大量存活对象时，必须要全程暂停用户程序，所以需要“stop the world”。
			（如果使用标记-清理，就需要更为复杂的内存分配器来处理空间碎片化的问题，这是一个权衡利弊的问题）
		两个收集器使用：
			Parallel Scavenge收集器：使用标记-整理算法
			CMS收集器：和稀泥的方式（多数时间使用标记-清除算法，暂时容忍内存碎片化，如果内存碎片程度达到影响对象分配，使用标记-整理）
			Shenandoah收集（最新）：使用读屏障计数实现整理过程中和用户线程并发执行
			
			

5、hotSpot的算法实现细节
	
	5.1 根节点枚举（找出所有gc roots）
		固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。
		存在的问题：
			所有收集器在根节点枚举都是必须暂停用户线程，也是stop world。根节点枚举是必须在一个保障一致性快照进行。
			（这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上）
		为什么要stop world？
			不冻结的话，根节点集合的对象引用关系不断发生变化，分析准确性不保证。
		如何解决根节点枚举问题，并且高效执行？
			目前主流Java虚拟机使用的都是准确式垃圾收集（准确式 GC 使用的对象访问定位方式是直接指针访问），
			并不需要一个不漏地检查完所有执行上下文和全局的引用位置。
			在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。OopMap可以理解为就是映射表，
			存储栈上的对象引用的信息，这是一种空间换时间的做法。
				（其实就是用类似映射表这种手段记录下来引用关系，时不时去更新下映射表，
				然后根节点枚举只需要扫描映射表就知道哪些地方存放引用了，而不用去进行全局扫描）
	
	5.2 安全点
		上述提到oopMap快速解决根节点枚举，但是什么时候更新oopMap更新呢？
		如果每条指令都生成一条oopMap，会产生大量的额外存储空间，所以hotSpot只是在特定位置记录这些信息，称为安全点
		因此GC不是随时随地来的，得到达安全点时才可以开始GC。
		一般会在如下几个位置选择安全点：（循环的末尾、方法临返回前、调用方法之后、抛异常的位置）。
		但是还有一个问题是需要考虑的：如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来？
			1、抢先式中断：垃圾收集时，系统主动让用户线程全部中断，如果发现还有不在安全点上的线程，回复那条线程执行，一会到安全点再中断。
				(现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件)
			2、主动式中断：垃圾收集需要中断线程时，不直接对线程操作，设置一个标志位，各个线程自己轮询这个标志位，为true时到最近的安全点自动挂起。
			
	5.3 安全区域	
		如果程序不执行的情况，如程序sleep、或者blocked状态，无法响应虚拟机中断请求。无法走到安全点中断自己。
		这个时候就需要安全区域来解决。
		安全区域指：能确保在某一段代码片段中，引用关系不会发生变化。在此区域内，任意地方垃圾回收都是安全的。
		如果发生根节点枚举，此时安全区中代码要离开，则有一个安全标识，让此线程继续等待。

	5.4 记忆集和卡表
		为解决对象跨代引用所带来根节点枚举问题，避免把整个老年代假如GC Roots扫描范围。新生代中建立了一个记忆集的数据结构
		实现方案（抽象的数据结构，用于记录从【非收集区域】指向【收集区域的指针集和】）：
			01：字长精度（每个记录精确到机器字长，该字包含跨代指针）
			02：对象精度（每个记录精确到对象，对象字段含跨代指针）
			03：卡精度（每个记录精确到内存区域，该内存区域有对象含有跨代指针（hotSpot使用））
		卡表：
			卡精度就是用卡表实现的记忆集。就是一个字节数组，然后数组每一个元素对应标识的内存区域中的特定大小的内存空间。
			在垃圾回收时，只需要筛选出卡表中变脏的元素，就能得到跨代指针，从而将他们假如GC Roots扫描中。
	
	5.5 写屏障
		解决卡表维护的问题，在其他分带区域中对象引用了本区域对象时，更新维护卡表。
		hotSpot使用写写屏障维护卡表状态。（写屏障可以看做虚拟机层面对引用类型字段赋值时的aop切面）。
		所以诞生写前屏障和写后屏障
	
	5.6 并发的可达性分析
		在标记阶段时，随着堆中对象的增大，增加stop world是成正比的。
		所以想解决或者降低用户现场的停顿，就需要再标记时，用户线程同时并发。要考虑两种情况
		（一是原本消亡的意向错误标记成存活，另外一个是存活的对象标记成消亡）
		所以为解决并发扫描时对象消失问题，产生了两种解决方案，增量更新和原始快照
		（这两种都是破坏三色图中其中的一个条件，这个暂时可不考虑）
		hotSpot中两者都有使用，cms是基于增量更新来做并发标记的，G1、Shenandoah用原始快照。
		

6、经典的垃圾收集器
	（新生代）
	6.1 serial收集器
		最基础最悠久的收集器，这个收集器是一个单线程工作的收集器
		（这里单线程指的是它进行垃圾回收时必须stop the world，而非只使用单个处理器单个线程垃圾回收）
		目前它仍然是"客户端”模式下默认新生代收集器，里面采用标记-复制算法，它相对其他收集器，简单而高效，
		并且他是收集器里额外内存消耗最小的（因为专心收集垃圾，没有其他线程的交互开销），一般客户端应用，
		分配内存较小，即使stop the world也可以控制十几毫秒。
	
	6.2 ParNew收集器（结合cms使用，jdk1.9退出历史舞台）
		实质上就是serial收集器的多线程并行版本，除了多线程之外，其余的跟serial完全一致。
		jdk5-7中，服务端模式下，首选的垃圾收集就是它，因为只有它和serial才能与cms收集器配合工作。
		parnew在单核处理器的环境中没有serial好，因为存在线程交互的开销。如果多核的话，对于系统资源的也能做到
			高效利用，并且默认开启的手机线程数与处理器核心数量相同
	
	6.3 Parallel Scavenge收集器
		与parNew类似，也是新生代收集器，也是标记-复制算法实现、也是并行收集的多线程。
		但是parllel scavenge关注点与cms不同，cms关注于优化缩短用户线程的停顿时间。parallel scavenge收集器
		是能够达到一个可控制的吞吐量
		（吞吐量=运行用户代码时间 / 运行用户代码时间 + 运行垃圾收集时间）
		有两个参数精确控制吞吐量：
			01：-XX：MaxGCPauseMillis (控制最大垃圾收集停顿时间)
			时间设置得小，垃圾收集快，但是是用空间换时间的代价换取的，设置小了，但是垃圾收集频率就变快了。（吞吐量也就下来了）
			02: -XX：GCTimeRatio 
			(直接设置吞吐量大小，就是垃圾收集时间占总时间的比率，默认为99%，即允许最大1%的垃圾收集时间)
		
	
	（老年代收集器）
	6.4 serial old收集器
		serial老年代版本，单线程，使用标记-整理算法。（主要意义就是客户端模式下的jvm使用）
		在服务端下，1.5之前与parallel scavenge搭配使用，另外一种就是作为cms的失败后备预案（在并发手机发生）
			concurrent mode failure时使用）
	
	6.5 parallel old收集器
		parallel scavenge老年代版本，支持多线程并发。基于标记-整理（jdk6后提供，5之前parallel scavenge位置很尴尬）
		在注重吞吐量或者处理器资源较为稀缺的场合，parallel scavenge加parallel old组合优先考虑。
	
	6.6 CMS收集器（基于标记-清除算法）
		一个以获取最短回收停顿时间为目标的收集器。分为4个步骤
		01：初始标记 02：并发标记  03：重新标记  04：并发清除
		初始标记和重新标记仍需要stop the world。初始标记很快，并发标记因为要比阿里所有对象图，所以慢但是
			不停顿用户线程。cms优点：并发收集、低停顿。
		缺点：01：对处理器资源敏感，如果处理器核心较少，有可能会降低系统吞度量
			  02：无法处理“浮动垃圾”，就是这次垃圾回收时并发用户线程所产生的垃圾对象。
			  03：因为基于标记-清除，所以会对大对象分配带来大麻烦。可能会造成频繁的full gc。
	
	6.7 G1收集器（Garbage First）
		是垃圾收集器的里程碑成果，正式使用于jdk9。
		它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。
		它是面向内存任何部分来组成回收集，衡量标准不再是它属于哪个分代，而是哪块内存垃圾数量最多，回收利益更大。这就是mixed gc模式。
		它也仍是遵循分代收集理论，不过是吧Java堆划分为多个大小相等的独立区域（region）。每个独立区域都可以扮演新生代
		老年代等空间。
		region中还有特殊的humongous区域，专门存储大对象。
		相对cms：他能指定最大的停顿时间，能够在关注吞吐量和关注延迟之间达到最佳平衡。并且有分region的内存布局、
		按收益态确定回收收集。
			但是在某些场景中，用户在运行过程中，G1、Shenandoah用原始快照。为了垃圾收集的内存占用和程序运行时额外
			负载都比cms高。
		所以在小内存cms大概率会优于G1，大内存上G1能更好的发挥优势。经验来讲，平衡点实在6-8G之间
		
		
7：虚拟机及垃圾收集器日志
	jdk9才开始通过“-Xlog”参数来解决之前虚拟机日志输出格式不统一的问题。还可以根据修饰器decorator要求每行
		日志输出附加额外内容。（比如time: 当前日期时间，pid：进程id，level：日志级别）
		
8：内存分配和回收策略
	1、对象优先分配到eden区，当eden区没有足够空间，先进行一次minor gc。通过配置-XX：+PrintGCDetails参数记录收集器日志参数。打印内存回收日志
		minor gc时，当前存活的对象放到survivor区，如果survivor区还是不够，直接放到老年代。
	2、大对象直接进入老年代，大对象是指大量需要内存连续空间的对象，比如大字符串，元素庞大的数组等。尽量避免短命大对象，有可能会导致
		内存足够但是提前触发垃圾回收，并且回收时复制对象时，产生大额内存开销。可以使用-XX：PretenureSizeThreshold指定大于这个对象的
		直接在老年代分配
	3、长期存活的对象将进入老年代。当决策那些存活对象需要放在新生代，哪些放在老年代情况，虚拟机使用年龄计数器（在对象头中）。
		经历minor gc一次，age就加一，第一次如果还存活，survivor还有空间，放到survivor区，默认到15次后，存活晋升到老年代。
		可以通过-XX：MaxTenuringThreshold=15来设置
	4、动态年龄判断：为了适应不同程序的内存状况，hotspot并不永远要求年龄必须达到多少次才晋升，如果survivor空间中相同年龄的对象
		总和大于survivor空间的一半，直接晋升老年代。
	5、空间分配担保：发生minor gc前，需要检查老年代最大可用的连续空间是否大于新生代所有对象总空间，条件成立，担保这次gc安全。
		如果不成立，会查看-XX：HandlePromotionFailure设置是否允许担保失败。允许的话，继续检查老年代最大可用连续空间是否大于历次
		晋升老年代对象的平均大小，大于的话，尝试风险的minor gc。小于直接full gc。

9：虚拟机性能监控、故障处理工具
	9.1：基础故障处理工具
		分为三类：01：商业授权工具（JMC以及JFR），02：正式支持工具（属于长期支持的工具）03：实验性工具
	9.2 jps虚拟机进程状况工具
		类似于unix中ps命令，列出虚拟机进程，并显示虚拟机执行主类名称。功能单一但使用频率非常高。
		jps [options] [hostid]，样例：jps -l(输出主类全名，如果是jar，输出路径) -v(输出虚拟机进程启动的jvm参数) 
			-q(只输出LVMID，省略主类名称)
	9.3 jstat虚拟机统计信息监视工具
        jstat [option vmid [interval(s/ms)] [count]]: option表示用户希望查询的虚拟机信息（类加载、垃圾收集、运行期编译状况），interval和count代表查询间隔和次数，省略表示只查一次
        例子：jstat -gc 2764 250 20
        -gc 监视java堆状况，包括eden区，两个survivor区，老年代，永久代等的容量，已用空间，垃圾收集时间合计等信息。
        -gcutil 跟gc基本相同，输出的为百分比
        -class：监视类加载器、卸载数量、总空间一级类装载所耗费的时间。
    9.4 jinfo: java配置信息工具
        jinfo的作用是实时查看和调整虚拟机各项参数。

    9.5 jmap: java内存映像工具
        jmap命令用于生成堆转储快照（heapdump或dump文件）
        jmap [option] vmid
            （-dump：生成java堆转储快照。 -finalizerinfo: 显示F-Queue等待finalizer线程执行finalize方法的对象。
                -heap：显示java堆详细信息，如哪种回收器、参数配置等。）
        jmap -dump:live,format=b,file=testjvm.bin 102321
    9.6 jhat: 虚拟机堆转储快照分析工具（就是分析jmap生成出来的dump文件，不过一般不使用）
    9.7 jstack: java堆栈跟踪工具
        jstack命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈集合。定位线程长时间停顿的原因，比如死锁、死循环、http挂起等。
        jstack [option] vmid
            （-F：当正常输出的请求不被响应时，强制输出线程堆栈。 -l：除堆栈外，显示关于锁的附加信息。 -m：如果调用到本地方法的话，可以显示C/C++的堆栈）

(以下这几个可视化界面例子在\com\cqyc\jvm\utiltest目录下)
    9.10 可视化工具（JHSDB：基于服务型代理的调试工具）
    9.11 JConsole: Java监视与管理控制台
    9.12 visualVM: 多合一障处理工具： 是功能最强大的运行监视和故障处理程序之一。

10、调优案例分析实战
    10.1 大内存硬件上的程序部署策略
        网站经常不定时出现长时间失去响应，如果大对象创建没经过年轻代，直接进入老年代，导致full gc14秒。
        两种方案：1、通过一个单独的java虚拟机实力管理大量的java堆内存。2、开集群，建立逻辑集群充分利用硬件资源。

    10.2 集群间同步导致内存溢出
        集群间共享数据如果使用非集中式寄存缓存做同步的话，不应该有过于频繁的写操作，会带来很大的网络开销

    10.3 堆外内存导致的溢出错误
        如果发生unsafe.allocateMemory的内存溢出报错，这个时候是因为直接内存虽然能被垃圾收集器回收，但是它并不能主动通知垃圾器回收，只能等待full gc出现后，顺便清理内存的
        废弃对象，否则就只能直接内存满了，直接抛异常。直接内存可以通过-XX: MaxDirectMemorySize调整大小。以下区域都会受到进程最大内存限制。32位机器一个进程最多分配1.6G。
         （直接内存、线程堆栈、socket缓冲区、 jni代码）

    10.4 外部命令导致系统缓慢
        用户每次调用都需执行一个shell脚本，脚本是通过java的runtime.getRuntime().exec()执行。每次调用服务器都会创建新的进程处理脚本命令。如果频繁操作，系统消耗增大。

    10.5 不恰当数据结构导致内存占用过大
        hashMap中100万个entry。导致进入新生代时，直接填满触发垃圾收集，因为survivor要复制，所以暂停时间明显变长。优化方案：将空间利用率压缩，比如long占用16个字节，
        如果不存在超int情况，建议使用int，增加空间利用效率。

    10.6 由Windows虚拟内存导致的长时间停顿
        像这总大对象，直接调率eden进入老年代




