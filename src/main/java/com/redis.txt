redis:
 1、跳跃表：
  	跳跃表是有序集合的底层实现之一
  	redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点，长度），而zskiplistNode用于表示跳跃表节点
  	每个跳跃表节点的层高都是1-32之间的随机数
  	同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
  	跳跃表中的节点按照分值大小进行排序，分值相同时，节点按照对象大小进行排序
  
 2、整数集合：
  	整数集合是集合键的底层实现之一
  	整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要的时，程序会根据新添加元素的类型，改变元素组的类型
  	升级操作为整数集合带来了操作上的灵活性，并且尽可能的节约了内存
  	整数集合只支持升级操作，不支持降级操作
  
 3、压缩列表：
  	压缩列表时列表键和哈希键的底层实现之一 ，它是一种为节约内存而开发的顺序型数据结构
  	压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值
  		previous_entry_length：
  			记录压缩列表前一个节点的长度。长度可以是1字节和5字节，前一节点长度小于254时，为1字节，大于254，为5字节。
  		encoding:
  			记录节点content属性所保存数据的类型以及长度。值为00、01、10开头表示为字节数组编码，11开头表示整数编码。
  		content:
  			保存节点的值		
  	添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但是出现几率不高（连锁更新，当previous_entry_length有1变为5时可能会存在此操作）


 4、对象：

  	上面介绍的数据结构并未直接用来实现键值对数据库，基于这些数据结构创建了一个对象系统。
  	redis中每个对象都由一个redisOBject结构表示，里面有三个关键属性: type、encoding、ptr（指向底层实现数据结构的指针）。
  	1、类型（type）：
  		string(字符串对象)、list(列表对象)、hash(哈希对象)、set(集合对象)、zset(有序集合对象)。
  		命令：object encoding KEY (查看对应key是用的数据结构)

  	2、encoding（编码）：
  		记录了对象所使用的编码，也即是说这个对象是用什么数据结构作为对象的底层实现。例如：int(long类型整数)，raw(简单动态字符串)，HT（字典），LinkedList(双端链表)，zipList（压缩列表）

  	3、字符串对象（string）:
  		1、里面的编码属性为三种：int, raw, embstr,如果保存整数值，属性编码将设置为int, 值保存在ptr属性里面。如果保存一个字符串，并且长度超过32位，那编码将设置为raw。小于32位，就用embstr属性保存。
  		2、embstr和raw区别：
  			1、embstr是保存短字符串的一种优化方式。在使用raw属性，会调用两次内存分配来分别创建redisObject结构和sdshdr结构。embstr则通过一次内存分配来分配一块连续内存空间，这一块连续空间包含redisObject和
  			sdshdr两个结构。
  			2、释放也同上
  			3、embstr保存了一块连续的内存空间里面，相较于raw更好的利用了缓存带来的优势。
  		3、long double类型表示的浮点数在redis中用的是字符串表示的。如果在计算上的话如：incrbyfloat key 2.9这种，redis会进行类型转换
  		4、int或者embstr类型，在进行一些操作时会转换为raw。如：append key "test11"; //往后面添加

 	4、列表对象（List）
 		1、编码分为两种：zipList和linkedList。zipList编码是用压缩列表作为底层实现。linkedList是用双端队列作为底层实现。
 		2、linkedList编码中包含多个字符串对象(stringObject), 注意：字符串对象是redis五种类型中对象唯一一种被其他四种类型对象嵌套的对象
 		3、当满足以下两个条件：保存的所有字符串元素长度都小于64字节，对象元素数量小于512个。不满足则使用linkedList编码。可以由配置文件中list-max-ziplist-value和list-max-ziplist-entries修改。

 	5、哈希对象（hash）
 		1、编码也分为两种：ziplist和hashtable，在ziplist属性时，同一键值对的两个节点总是紧挨在一起的。hashtable编码使用字典作为底层实现，每个键值都是单独的一个字符串对象。
 		2、哈希对象满足两个条件时，使用ziplist编码：键值都小于64字节，键值对数量小于512个。不满足时使用hashtable编码
 		3、当zipList编码不满足时，会进行编码转换，转换为hashtable编码，由max-ziplist-value和hash-max-ziplist-entries选项配置

 	6、集合对象（set）
 		1、编码分为两种：intset或者hashtable。
 		2、intset使用整数集合底层实现，hashtable使用字典作为底层实现。
        3、使用inetset满足两个条件：集合对象都是整数值，元素数量不能超过512。不满足则改为hashtable。
        4、可根据配置文件中set-max-intset-entries修改

    7、有序集合对象
        1、编码两种：ziplist(压缩列表)、skiplist(zset数据结构), 压缩列表是按分值从小到大进行排序的，zset里面包含了一个字典和一个跳跃表
        2、zsl跳跃表按分值从小到大排序，zrank、zrange等命令都是基于跳跃表api实现。
        3、zset需要同时使用跳跃表和字典来实现：因为相比单独使用，同时使用性能更高，比如单独使用字典，执行范围操作zrange等命令时，至少需要O（NlogN）时间复杂度。
        4、使用ziplist满足一下两个条件：元素数量小于128，成员长度小于64，可以通过zset-max-ziplist-entries等选项设置。

    8、类型检查和命令多态
        1、类型检查：在执行类型特定的命令之前，redis会先检查输入键的类型的正确性。如果错误，返回一个类型错误。
        2、命令多态：执行llen命令，列表可能会对ziplist和linkedlist两种编码可用，对于ziplist来讲，使用的是ziplistLen函数返回，而linkedlist用listLength函数返回
            这里我们可以认为llen命令是多态的，无论使用哪个编码，命令正常执行。
        3、del、expire等命令和llen等命令区别在于，一个是基于类型的多态，一个是基于编码多态。在执行时都会判断编码或者类型的判断，选择使用哪个函数，这就是多态。

    9、内存回收
        1、redis构建了一个引用计数实现内存回收机制。由redisObject结构中refcount属性决定
        2、创建时，初始化为1，当被新程序使用时，引用计数加一，不使用时减一，为0时，内存自动被释放

    10、对象共享
        1、将多个键共享同一个值对象需执行两个步骤：（1）将数据库键的值指针指向一个现有的值对象 （2）将被共享的值对象引用计数加一
        2、redis初始化服务器时，会创建一万个0至9999所有整数值的字符串对象。可以由redis_shared_integers配置修改
        3、因为包含字符串的对象验证时复杂度O(N)，包含多个值如列表对象和哈希对象，复杂度为O(N^2)，所以redis只对包含整数值的字符串对象进行共享。

    11、对象的空转时长（lru）
        1、redisobject结构包含了一个属性lru,该属性记录了对象最后一次被命令程序访问的时间。object idletime打印给定键的空转时长
        2、如果服务器打开maxmemory选项，并且服务器用于内存回收算法为volatile-lru或allkeys-lru时，此时当占用内存数超过maxmemory选项所设置上限值，空转时间长的那部分会优先被服务器释放。



5、单机数据库的实现
    1、数据库
        1、redis服务器将所有数据库保存在服务器状态redis.h/redisServer结构的db数组中，为redisDb结构
        2、有dbnum属性决定创建多少个数据库，默认16，可更改  

    2、读写键空间时的维护操作
        1、读取一个键时，服务器会根据键是否存在来更新服务器键空间命中次数或不命中次数，可以在info stats命令keyspace_hits和_missess属性查看
        2、读取一个键后，会更新lru（最后一次使用）时间 
        3、读取一个键时，如果发现该键已过期，则会先删除此键，在做余下操作
        4、客户端使用watch命令时，对键进行修改时，会被标记为dirty,从而让事务注意到这个键已经被修改
        5、每次修改一个键，会对dirty键计数器增一，会触发持久化以及复制操作。

    3、设计过期时间
        1、4种命令：expire key ttl, pexpire key ttl, expireat key timestamp, pexpireat key timestamp. 前三种其实最终经过转换之后，都会使用pexpireat执行。
        2、保存过期时间：redisDb结构中expires字典保存了数据库中所有键的过期时间，当执行过期命令后，会往这个过期字典里面指向对应键，以及设置过期时间。
        3、移除过期时间：presist移除过期时间
        4、过期键判定：1）检查键是否存在过期字典，存在取过期时间。2）判断当前时间戳是否大于过期时间，是则过期，否则未过期

    4、过期键删除策略
        1、定时删除：对内存友好，能尽可能释放过期键所占用内存。缺点是对cpu时间不友好，在过期键较多时，会占用cpu时间。影响服务器响应以及吞吐量。
        2、惰性删除：对cpu友好，取值的时候才会删除，对内存不友好，如果没取值，这个过期键会永久存在，存在内存泄露风险
        3、定期删除：上面两种方式的折中，每隔一段时间执行一次删除过期操作，并限制删除操作执行时长和频率减少cpu时间。
        4、redis使用的是惰性删除和定期删除两种策略

    5、定期删除策略的实现
        1、有redis.c/activeExpireCycle函数实现，当服务器周期性操作serverCron函数执行时，active这个函数就会被调用，分多次遍历服务器中各个数据库。
        2、从数据库的expires字典随机检查一部分键过期时间，并删除其中的键。

    6、AOF、RDB复制功能对过期键处理
        1、执行save和bgSave创建一个新的RDB文件，对于主服务器写入，会删除过期键在写入，从服务器不管，直接所有键写入。
        2、AOF生成，如果某个键已过期，但没有被惰性删除或者定期删除，aof也会写入，如果这个键被删除，会向aof追加一条命令，显式删除该键
        3、aof重写过程中会对键进行检查，删除过期键后在写入
        4、复制：服务器运行复制模式下，从服务器动作由主服务器控制，如在get过期键中，如果读的是从服务器，如果这个键没删除，则读取得到，读的是主服务器，会向从服务器发送删除指令，然后返回空。

6、RDB文件的实现
    1、RDB创建与载入
        1、由save和bgsave命令执行，save会阻塞服务器进程，bgsave会fork一个子进程创建。
        2、save、bgsave、bgrewriteaof三个命令不能同时执行。互斥的
    2、rdb保存条件
        1、redis修改配置文件，save 900 1, save 300 10, save 60(秒) 10000(改变次数)
    3、dirty计数器和lastsave属性
        1、dirty计数器记录距离上一次成功执行save或者bgsave命令后，对数据库状态进行多少次修改
        2、lastsave记录上一次成功执行save命令或者bgsave
    4、检查保存条件是否满足
        1、serverCron函数默认每隔100毫秒执行一次，会检查save选项设置保存条件是否满足，就执行bgsave命令。
        2、当lastsave加上saveparams设置的时间，满足比如300秒修改10次条件时，就会执行bgsave命令。bgsave执行完成后，dirty重置为0

7、AOF持久化
    1、AOF持久化的实现
        1、命令追加：如服务器打开aof,则执行完一个写命令后，会追加到aof_buf缓冲区。
        2、aof文件写入和同步：将内容写入aof_buf缓冲区之后，命令执行完成之后，会根据配置的appendfsync的值来考虑调用flushAppendOnlyFile函数行为来写入aof文件中。
            1）appendfsync有always, everysec, no三个配置，默认时everysec。
            2）文件写入和同步，加上缓冲区，可能存在安全问题，redis提供fsync和fdatasync两同步函数，可以强制将操作系统让缓冲区数据写入硬盘。
            2）在效率和安全方面，everysec保证每个事件循环都将aof_buf缓存所有内容写入aof文件，并每隔一秒就在子线程同步文件。服务器即使宕机，也只丢失一秒钟的命令。
    2、AOF文件的载入与数据还原
        1、创建一个伪客户端，然后从aof文件读取一条写命令，使用伪客户端执行写命令,然后重复读写这两步，知道命令处理完。
    3、AOF重写
        1、产生原因：随着时间推移，aof文件内容记录越来越多，文件越来越大。为了解决提及膨胀问题，redis提供重写（rewrite）功能。
        2、重写的实现：aof重写不是读取之前已经创建的aof文件，而是新建一个aof文件，然后将现在服务器上的key中的值读取出来，直接把现有值以添加的命令加入到新的aof文件中。
            1）注意：如果读取中key中元素超过64个元素，为了方式缓冲区溢出，会拆分成多个命令，来写入到新的aof文件中
        3、在执行bgrewriteaof命令时，redis会维护一个aof重写缓冲区，然后开一个子进程记录所有写命令。再将缓冲区内容追加到新aof文件的末尾。

 8、事件
    1、redis服务器是一个事件驱动程序，需要处理两类事件：文件事件、时间事件
    2、文件事件
        1）redis基于reactor模式开发自己的网络事件处理器。文件事件处理器使用I/O多路复用监听多个套接字,并根据套接字目前执行的任务来为其关联不同的事件处理器。
    3、文件事件处理器的构成
        1）由四个部分组成：套接字、I/O多路复用程序、文件事件分派器（dispatcher）、以及事件处理器
        2）文件事件是对套接字操作的抽象，一个服务器通常会连接多个套接字，有可能会并发的出现
        3）I/O多路复用负责监听多个套接字，并向文件事件分派器传送产生了对应文件事件的套接字。
        4）对于文件事件产生可能会存在并发，但是I/O多路复用程序会将所有产生事件的套接字放在同一个队列中。
        5）通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。
        6）最后由文件事件分派器根据事件类型，调用相应的事件处理器
    4、I/O多路复用程序的实现
        1）所有功能就是包装常见的select、epoll、evport、kqueue等多路复用函数实现。
    5、文件事件类型
        1）AE_readable事件：当客户端执行写（write）、close、应答acceptable等操作时，套接字触发读readable事件；
        2）AE_writable事件：当客户端执行读（read）操作时，套接字变为可写，触发writable事件。
        3）当上述两个事件同时发生时，套接字优先处理readable事件，即客户端此时在执行写命令。
    6、文件事件处理器(networking.c/)
        1）连接应答处理器acceptTcpHandler：处理各个客户端应答,为监听套接字关联谅解应答处理器。redis服务初始化时，关联AE_readable事件，当connect函数执行时，套接字产生readable事件
        2）命令请求处理器readQueryFromClient: 负责从套接字中读入客户端发送到的命令，上一步连接成功后，服务器将套接字readable事件和命令处理器关联，以后面执行相应的套接字读入操作。
        3）命令回复处理器sendReplyToClient: 负责将服务器执行命令通过套接字返回给客户端，根writable事件和命令处理器关联，以方便后面套接字写入操作。

    7、时间事件
        1）事件事件分为定时事件和周期性事件，目前redis只使用了周期性事件
        2）服务器一般情况下只执行serverCron函数一个事件事件，为周期事件。
        3）文件事件和时间事件为合作关系，服务器会轮流处理两种事件，不会发生抢占。在时间事件等待过程中，优先处理文件事件。

9、客户端
    1、客户端属性
        属性一般分为两类，通用属性，无论客户端执行什么工作，都要用到这些属性。另外一类就是特定功能的相关属性。比如执行事务时mstate属性。watch命令时watched_keys属性。
        1）套接字描述符：由fd属性记录，伪客户端如aof文件或lua脚本这种，fd值为-1. 普通客户端使用套接字跟服务器通信，所以必为大于-1的整数。client list命令可以列出所有客户端。
        2）标志：flgs记录客户端角色，已经目前所处状态，例如redis_lua_client标识专门处理lua脚本的伪客户端。redis_monitor表示客户端正在执行monitor命令等。
        3）pubsub和script load命令的特殊性：通常情况下，redis只会对进行修改的命令写入到aof中，但是pubsub是通知订阅者，虽然没修改数据库，但服务器状态发生了改变。所以会使用redis_force_aof标志强制刷新。

    2、输入缓冲区
        1）客户端状态的输入缓冲区用于保存客户端发送的命令请求。
        2）里面有个sds属性的querybuf字段，将设置值的命令保存到这个字段中。这个缓冲区会根据输入内容动态缩小或扩大，最大大小不得超过1GB。

    3、输出缓冲区
        1）执行命令回复保存在输出缓冲区里面，每个客户端有两个输出缓冲区。一个固定大小，一个可变。固定的主要保存长度比较小的回复。如OK，简短的字符串等。
        2）固定大小缓冲区有buf和bufpos两属性组成，buf是一个为redis_reply_chunk_bytes字节数组，默认为16KB。
        3）当buf空间使用完之后，就会使用可变大小缓冲区，可变大小缓冲区由reply链表和多个字符串对象组成。

    4、客户端的创建与关闭
        1）创建普通客户端添加到clients链表中，表示相关状体啊
        2）关闭客户端可能有很多原因，比如客户端进程杀死，带有不符合协议格式的命令请求等。如果用户设置timeout选项，那么客户端空转超过timeout选项时，客户端被关闭。当然如主服务器和从服务器通信，打上了redis_blocked标志时，不会被关闭。
        3）服务器使用两种模式限制缓冲区大小：硬性限制，软性限制。超过硬性限制则直接关闭，超过软性限制，则记录达到这个限制的其实时间，而后继续监视，如一段时间持续超过，则关闭。有client-outpu-buffer-limit选项决定。


10、服务器
    1、命令请求的执行过程
        1）读取命令请求：客户端发送命令，服务端读取客户端输入缓冲区中并且按照相应套接字协议格式读取命令，然后进行分析客户端中argv属性和argc属性。最后调用命令执行起，执行客户端执行命令。
        2）命令执行器：
            1、查找命令实现：查找argv[0]中的参数得到指定的命令，然后取命令表找相应的命令实现，如set命令找的是setCommand，每个命令结构都是redisCommand结构。redisCommand里面有几个重要属性：name、sflags等。比如set sss "hello world",实现函数是setcommand,参数个数为-3，sflags为wm，表示为写入命令，并且服务器应对占用内存进行检查。
            2、执行预备操作
                执行命令所需的函数、参数、参数个数收集齐全后，看是检查一些预备操作，确保正确、顺利的地执行，包括检查客户端状态cmd指针是否为NULL。检查是否需要auth命令。如果服务器打开maxmemory功能，先检查服务器占用情况。等等。。。。注意：服务器复制或集群模式下，预备操作更多。
            3、调用命令的实现函数
                client->cmd->proc: 执行指定操作，会产生相应的命令回复，保存在缓冲区里面的buf属性喝reply属性。
            4、执行后续操作
                执行完命令后，对于后续工作比如开启慢查询后，记录慢查询日志。开启aof的话，将执行的命令写入aof缓冲区等等。
        
    2、serverCron函数
        1）serverCron默认每隔100毫秒执行一次。负责管理服务器的资源，并保持自身良好运转。
        2）更新服务器时间缓存
            1、在redisServer对象中的unixtime、mstime中，因为serverCron每隔100ms，所以这两个属性精度不准确。通常用在打印日志，更新lru时钟等精确度要求不高的场景。像对键设置过期时间需要高精度则每次执行系统时间等。
            2、lru时钟计算一个数据库键的空转时间。
            3、更新服务器每秒执行命令次数：serverCron函数中trackOperationsPerSecond函数会100ms执行一次，以抽样计算方式，通过info status命令执行
            4、处理sigterm信号：启动服务器时，redis会为服务器进程sigterm信号关联处理器sigtermHandler函数，，服务器接收到sigterm信号，打开服务器shutdown_asap标识。serverCron执行时，都会对shutdown_asap属性检查，决定是否关闭服务器。

    3、初始化服务器
        1）初始化服务器状态结构：有redis.c/initServerConfig函数完成，一般设置服务器运行ID，服务器默认端口号，创建命令表等。设置服务器状态属性基本都是一些整数、浮点数、字符串属性等。
        2）载入配置项：启动服务器时，通过给定的配置参数或文件修改服务器默认配置
        3）初始化服务器数据结构：执行initServer函数，将服务器状态初始的一些数据结构分配内存。还有其他的比如服务器设置进程信号处理器、创建共享对象、打开服务器监听端口
        4）还原数据库状态：这个时候开启aof则读取aof文件还原数据，没开启就读取rdb文件还原
        5）执行事件循环：最后一步，开始执行事件循环，开始接收客户端命令请求。



第三部分：多机数据库
1、复制 （主从模式）
    1）redis中，用户可以通过执行slaveOf命令或者设置slaveof配置选项，让一个服务器复制另一个服务器。复制的为从服务器，被复制的为主服务器。例如：slaveof 127.0.0.1 63379。主从双方数据库保存相同数据。

    2）旧版复制功能实现 
        1、分为同步sync和命令传播command propagate两个操作，同步操作将从服务器数据库状态更新至主服务器所处的数据库状态，命令传播用于主服务器数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从重新回到一致状态。
        2、同步sync
            1）客户端向服务器发送slaveof命令，从服务器首先执行同步操作。从服务器向主服务器首先发送sync命令，然后收到命令的主服务器执行bgsave命令，会后台生产RDB文件，并使用缓冲区记录从现在开始执行的左右写命令，
                rdb文件发送给从服务器，从服务器执行bgSave命令，然后主服务器将缓冲区命令发送给从服务器，至此保持一致。
        3、命令传播
            1）主服务器更新了key的状态，主服务器向从发送命令传播，让从在执行一次相同的更新命令，保证主从的一致状态。
        4、旧版复制功能的缺陷
            1）从对主的复制分两种情况：一是初次复制，就是第一次要复制的主服务器，没什么问题。二是断线后重新复制：在命令传播阶段中主从因为网络原因中断复制，然后自动重连后，继续复制主服务器。对于第二种断线复制，效率非常的低
            2）sync命令是非常消耗资源的操作：一是要bgsave命令生成RDB文件，这个会耗费大量cpu、内存、i/o等资源。二是RDB文件发送给从，需要大量的带宽流量，并对主响应请求产生相应影响。三是从在载入文件期间，会阻塞无法处理请求。

    3）新版复制功能实现
        1、使用psync命令代替sync命令。psync具有完整重同步、和部分重同步两种模式。完整重同步跟初次复制步骤差不多，部分重同步用于处理断线重复制，当断线重连后，主将断开期间执行的写命令发送给从，直至更新主当前状态。
        2、部分重同步的实现
            1）分成三个部分：一是主从服务器的复制偏移量，二是主服务器的复制积压缓冲区，三是服务器的运行ID。
            2）复制偏移量：主从双方各维护一个复制偏移量，主向从传播N个字节数据时，复制的偏移量加N，从接收主传播N个字节数据时，复制偏移量也加上N。主从处于一致状态，偏移量相等，否则未处于一致状态。
            3）复制积压缓冲区：是由主服务器维护的一个固定长度先进先出（FIFO）队列，默认1MB。主在命令传播时，在发送给从命令时，也会将写命令入队到复制积压缓冲区中。如果断线重连后从的复制偏移量存在于缓冲区中，则执行部分重同步，反之则执行部分重同步。这个缓冲区的大小由配置文件中repl-backlog-size选项决定。
            4）服务器运行ID：每个服务器都有自己的运行ID，初次复制时，从会把ID保存下来，断线重连后，从向当前连接的主发送这个运行ID。如果相同，在看缓冲区，决定是否执行部分重同步，不一致则执行完整重同步。

    4）psync命令的实现
        1、调用方法有两种：一是请求完整重同步，发送PSYNC ? -1命令， 二是判断已经复制过了，然后发送PSYNC <runid> <offset> 命令，runid是主运行ID，offset是从复制偏移量。

    5）复制的实现
        1、步骤一：设置主服务器的地址和端口，步骤二：建立套接字连接，步骤三：发送ping命令，步骤四：身份验证，步骤五：发送端口信息，此时从服务器执行replconf listening-port <port-number>命令。步骤五之前从都是主的客户端
        2、步骤六：同步，从向主发送psync命令。步骤七：命令传播
        3、其他：心跳检测，每秒一次，replconf ack <offset>（当前的复制偏移量），这个命令目的是：检测主从服务器的网络连接状态，辅助实现min-slaves配置选项，检测命令丢失。


2、Sentinel（哨兵模式）
    1）介绍：sentinel是redis的高可用性解决方案：由一个或多个sentinel实例组成的sentinel系统可以监视多个主服务器，一级所属的从服务器，如主服务器下线，自动将从服务器升级为主，然后有新的主服务器代替原来的主服务器处理请求。sentinel系统选举使用的是raft算法的实现。

    2）启动并初始化sentinel
        1、启动命令：redis-sentinel /path/to/your/sentinel.conf 或者  redis-server /path/to/your/sentinel.conf --sentinel
        2、初始化服务器：sentinel本质上是一个运行在特殊模式下的redis服务器，启动时相较于普通redis服务，因用不到数据库，像RDB或AOF文件用不到，所以不会载入。还有像事物命令、数据库操作方面命令等都不使用。
        3、使用sentinel专用代码：将一部分普通redis服务器代码替换成sentinel专用代码。如redis.h/REDIS_SERVERPORT常量替换为sentinel.c/REDIS_SENTINEL_PORT。
        4、初始化sentinel状态：应用了sentinel专用代码后，会初始化一个sentinelState结构，里面保存了入主服务器的信息，执行脚本数量等字段。
        5、初始化sentinel状态的masters属性：字典的值对应的是sentinel.c/sentinelRedisInstance结构，每一个instance代表一个被sentinel监视的redis服务器实例，这个实例可以是主服务器、从、或者另一个sentinel。
        6、创建连向主服务器的网络连接：sentinel会创建两个连向主服务器的一部网络连接，一个是命令连接，收发命令的，第二个是订阅链接，专门订阅主_sentinel_:hello频道。

    3)获取主从服务器信息
        1、sentinel默认十秒一次频率给主服务器发送INFO命令，获取主当前信息，可以从主返回的信息得到两条信息，一是主服务器本身信息，二是主下面从的相关信息。
        2、如果从主那边发了新的从信息，还会对新的从发送命令连接和订阅连接。

    4）向主和从发送信息
        1、默认情况向主和从以两秒一次的频率发送publish的命令：publish _sentinel_:hello:xxxxxx

    5)接收主和从的频道信息
        1、当sentinel与主和从建立订阅连接之后，sentinel会向服务器发送以下命令：subscribe _sentinel_:hello，这个订阅会持续到与服务器断开为止。
        2、也就是说，sentinel既通过命令连接向_sentinel_:hello频道发送消息，又通过订阅连接接收该频道消息。
        3、当有多个sentinel同时监视一个主服务器，则一个sentinel给主服务器发消息，其他的sentinel都能接收到该消息。
        4、所以sentinel可以通过频道发现新的sentinel时，会为其创建新的实例结构。
        5、sentinel之间不会创建订阅连接

    6）检测主观下线状态
        1、简述：默认情况下，sentinel会以每秒一次的频率向所有与他穿件命令连接的实例发送ping命令，以此来判断是否在线。
        2、ping命令回复分为两种：有效回复、无效回复
        3、sentinel配置文件中down-after-milliseconds选项指定了sentinel判断实例进入主观下线所需时间长度
        4、主观下线时长选项的作用范围包括到监控的主服务器，一级旗下的从服务器，和监视同一个主服务器的sentinel。
        5、多个sentinel设置主观下线时长可能不同：每个sentinel设置的down-after-milliseconds不同，sentinel1设置了1000毫秒，另外一个sentinel设置了20000毫秒，所以可能不同。

    7）检查客观下线状态
        1、当sentinel将一个主服务器判断主观下线后，为确认服务器真的下线，会向同样监视这一服务器的sentinel进行询问。当sentinel从其他sentinel那里接收到足够数量下线判断时，就会判定客观下线，并对其执行故障转移。
        2、发送sentinel is-master-down-by-addr命令，询问其他sentinel是否同意主服务器已下线命令
        3、接收上面命令回复，其他sentinel收到上述命令后，会检查主服务器是否下线，并返回源sentinel相关down_state及其他两个参数
        4、源sentinel统计其他sentinel返回的结果，当超过自己配置的quorum参数的值，就将主服务器设置为客观下线
        5、同理不同sentinel判断客观下线的条件可能不同。

    8）选举领头sentinel
        1、一个主服务器被判客观下线时，各个sentinel进行协商，选举领头sentinel，由领头sentinel对下线服务器进行故障转移。
        2、每次进行选举时，不管成功与否，所有sentinel配置纪元（计数器）自增一次。一个配置纪元里面，都有一次将某个sentinel设置为局部领头，设置后不可更改。
        3、设置局部领头规则是先到先得，最先的源sentinel会被标记为局部领头，其他的再来会拒绝。
        4、如果某个sentinel设置成局部领头，并得到了半数以上的支持，那就会设置为领头sentinel。

    9）故障转移
        1、在下线的主属下的所有从里面，挑选一个从，转换为主服务器。挑选出来从服务器状态良好、数据完整的从，然后发送salveof no one命令，从而转换为主。
            挑选规则：有一个列表，包含所有主从信息，然后开始第一步删除处于断线的从，第二步是删除五秒没有回复sentinel发送info命令的从，第三步删除超过down-after-millseconds*10ms的从服务器。最后在根据优先级比如复制偏移量哪个最多，或者运行ID顺序等。
        2、修改从服务器的复制目标
            领头sentinel让所有从服务器去复制新的主服务器，可以通过slaveof命令实现。
        3、将旧的主服务器变为从服务器
            sentinel向重新上线的主服务器发送slaveof命令，让他变为从服务器。


3、集群
    简介：redis集群是redis提供的分布式数据库方案，通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

    1、节点
        1）一个redis集群由多个节点组成，每个节点相互独立，要组建成一个真正工作的集群，需要连接节点，使用cluster meet命令完成，然后对指定节点进行handshake(握手)
        2）启动节点：redis服务器在启动时根据cluster-enabled配置选项决定是否开启集群模式。开启后节点会继续使用单机模式下的相关功能组件，并调用clusterCron函数，来负责执行集群模式下的常规操作。例如给其他节点发送gossip消息，检查节点是否断线等。
        3）集群数据结构：clusterNode来记录自己的状态，里面有一个link属性，是clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入输出缓冲区等。
        4）cluster meet实现：握手时创建一个clusterNode结构，然后接受后，B对A也会创建一个clusterNode结构。然后返回给A一个PONG消息，A接收到后，A给B发送ping消息，然后B接收后返回pong。AB握手完成，然后再通过Gossip协议让其余节点跟B开始握手。

    2、槽指派
        1）redis集群通过分片的方式来保存数据库的键值对，整个集群分为16384个槽(slot)，数据库每个键都属于这16384个槽的其中一个。使用cluster addslots xxx命令分配给节点对应的槽。
        2）记录节点的槽指派信息：clusterNode结构的slots属性和numslot属性记录节点负责处理那些槽，slots属性二进制数组，长度是2048个字节，包含16384二进制位。slots数组在索引i上二进制位为1，标识节点负责处理该槽，numslot标识处理的槽数量。
        3）传播节点的槽指派信息：一个节点除了记录自己的槽信息之外，还会将自己的slots数组通过消息发送给集群中的其他节点。传到其他节点后，其他节点会把你的slots数组保存更新，这样集群中每个节点都能知道16384个槽分别指派了集群中的那些节点。
        4）记录集群所有槽的指派信息：clusterState结构中slots数组记录了集群中所有16384个槽的指派信息。slots数组包含16384个项，每个项指向clusterNode结构。如果槽指派信息只保存在clusterNode.slots里，会出现一些无法高效解决的问题，而clusterState.slots数组存在解决了。

    3、在集群中执行命令
        介绍： 在对数据库16384个槽进行指派后，进群进行上线状态，这时客户端可以向集群节点发送数据命令了。接收命令的节点会计算出属于哪个槽，检查是否指派给自己，如果在当前节点，执行，不在的话返回moved错误，指引客户端转向正确节点，并再次发送执行的命令。
        1）计算键属于哪个槽：CRC16(key) & 16384,计算键CRC-16校验和，然后与上16383，算出槽号。执行命令时cluster keyslot。
        2）判断槽是否由当前节点负责处理：如果clusterState.slots[i]等于clusterState.myself，说明槽i由当前节点负责，否则返回moved错误，并指引转向能处理的节点。
        3）MOVED错误：moved错误的格式：moved <slot> <ip>:<port>,对于客户端显示来说，moved错误是隐藏的。
        4）节点数据库的实现：其实跟单机数据库实现一样，但是只能用0号数据库，此外在clusterState结构中有一个slots_to_keys跳跃表来保存槽与键之间的关系。分值就是对应槽号。

    4、重新分片
        重新分片操作可以将任意数量已经指派给源节点的槽指派给另一个节点(目标节点)，然后让源节点的键值对移动到目标节点。
        1）可以在线运行，由redis集群管理软件redis-trib负责执行
        2) redis-trip发送cluster getkeysinslot <slot> <count>命令给源节点，然后源节点返回最多count个属于槽slot的键，第三步redis-trip对于每个返回键向源节点发送一个migrate命令，最后源节点根据migrate命令指示将键迁移至目标节点。

    5、ASK错误
        源节点迁移至目标节点时，如果客户端来命令了，现在源节点没找到，源节点就会返回给客户端一个ask错误，然后指引客户端转向正在导入槽的目标节点。跟moved错误一样，对于客户端而言是隐藏的。
        1）cluster setslot importing命令实现：clusterState结构中importing_slot_from数组记录当前节点正在从其他节点导入的槽，importing_slot_from[i]不为空，标识当前节点正在导入槽。使用命令cluster setslot <i> importing <source_id>
        2)cluster setslot migrating命令：clusteState结构的migrating_slots_to数组记录当前节点正在迁移至其他节点的槽。migrating_slots_to[i]不为空，表示正在迁移。

    6、复制与故障转移
        redis集群中节点分为主节点和从节点，主节点用于处理槽，从用于复制主节点。如果主节点下线，就会从从节点选举一个成为主节点。
        1）设置从节点：向一个节点发送命令cluster replicate <node_id>, 让接收命令节点成为node_id所指定的从节点。接收到命令后，该从节点回将自己clusterState.myself.slaveof指针指向node_id对应节点的clusterNode结构，然后修改自己clusterState.myself.flags中属性，有redis_node_master变为redis_node_slave标识，最后调用复制代码。
        2）故障检测：集群中每个及诶单都会定期向其他节点发送ping消息。如果在一定的时间内，没收到发出去ping消息的回应，就是pong。就先标记为疑似下线状态（PFail），然后在广播到其他节点，其他节点收到消息后，会把cluster_node结构中的fail_reports链表添加一个下线报告。当集群内超过一半的主节点认为疑似下线节点下线时，就标记为下线，并广播关于主节点的fail消息。
        3）故障转移：第一步在下线的从节点中选取一个，第二步选取的从节点执行slaveof no one命令，成为主节点，第三步新主节点撤销所有对已下线主节点的槽指派，并将这些槽全部指向自己。第四步 广播一条pong消息，让其他节点知道自己成为老大了。最后开始处理命令请求。
            1、选举新节点：也是采用投票的方式，每个从节点支持的节点大于N/2+1时，则成为新主节点。跟sentinel选举一样的，都是raft算法。

    7、消息：
        发送消息一下五种：meet消息、ping消息、pong消息、fail消息、publish消息。一条消息由消息头（header）和消息正文（data）组成。
        1）消息头：消息头包含消息正文之外，还记录了发送者自身的信息
        2) meet、ping、pong消息的实现：通过gossip协议交换信息。




第四部分了哟：独立功能的实现

1、发布与订阅
    简介：redis发布订阅功能由publish、subscribe、psubscribe等命令组成。
    
    1、订阅频道：客户端执行subscribe命令订阅频道时，服务器会创建一个pubsub_channels字典，如果第一次创建他是一个空链表，不是则往空链表插入一条数据。退订频道：unsubscribe退订一个频道，取消pubsub_channels链表上的关联关系。

    2、模式的订阅和退订：跟上述一样，也会创建一个pubsub_patterns属性，链表每个节点包含一个pubsubPattern结构，这个结构中的pattern属性记录被订阅的模式，client属性记录订阅模式的客户端。
        1）订阅模式：执行psubscribe时，有两步，第一时新建一个pubsub pattern结构，设置相关pattern、client属性，第二步将pubsubPattern结构添加到链表表尾。
        2）退订模式：执行punsubscribe命令

    3、发送消息
        一个客户端执行publish <channel> <message>命令时，服务器会执行一下两个动作。
        1）将消息发送给频道订阅者：找pubsub_channels字典中的订阅者名单，其实就是找链表，找到之后把消息发给订阅者就好了。
        2）将消息发送给模式订阅者：pubsub_patterns链表记录了模式的订阅关系，所以需要遍历整个pubsub_patterns链表，查找与channel相匹配的模式，然后在发送给满足条件的所有订阅者。

    4、查看订阅信息
        1）pubsub channels [pattern]，用于返回服务器当前被订阅的频道，pattern可选
        2）pubsub numsub [channel-1...],接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。
        3）pubsub numpat用于返回服务器当前被订阅模式的数量。


2、事务
    简介：redis通过multi、exec、watch等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行其他客户端的命令请求。他会将事务中所有命令执行完毕，采取处理其他客户端请求。redis事务以multi开始，输入相关命令，然后以exec提交给服务器执行。

    1、事务的实现
        事务开始到结束通常会经历三个阶段：事务开始、命令入队、事务执行。
        1）事务开始：multi命令的执行标志着事务的开始，multi命令可以将执行该命令的客户端从非事务状态切换至事务状态，将flags属性打开redis_multi标识。
        2）命令入队：一个客户端处于非事务状态，客户端发送命令会立即执行。如果处于事务状态：服务器会根据不同命令执行不同操作，如exec、discard、watch、multi其中一个，服务器立即执行，除此其他命令都放在事务队列里面，然后向客户端返回queued回复。
        3）事务队列：每个redis客户端都有自己的事务状态，保存在mastate属性里面。事务状态包含一个事务队列multCmd，以及事务队列长度字段，事务队列以先进先出（FIFO）方式保存入队的命令。
        4）执行事务：当处于事务状态的客户端发送exec命令时，会立即执行，并且服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将结果全部返回。

    2、WATCH命令的实现
        介绍：watch命令时一个乐观锁， 它可以在exec命令执行之前，监视人意数量的数据库键，并在exec命令执行时，检查被监视的键是否有被修改过，如果修改过，则拒绝执行事务，返回失败的空回复。
        1）使用watch命令件事数据库键：redisDB中都保存了一个watched_keys字典，这个字典是被watch命令监视的数据库键，而字典的值是一个链表，链表记录所有监视相应数据库键的客户端。
        2）监控机制的触发：对数据库进行修改的命令，如set、lpush等，执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查。如果有正在监视的键被修改过，会把监视的客户端的redis_dirty_cas标识打开，表示事务安全性已经被破坏。
        3）判断事务是否安全：当服务器接收到客户端发来的exec命令时，服务器根据上述redis_dirty_cas标识来决定是否执行事务，如果打开，拒绝执行该事务。

    3、事务的ACID性质
        在传统的数据库关系性数据库中,常常用ACID来检验事务功能的可靠性和安全性。在redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）。当事务运行特定持久化模式，才具有耐久性。
        1）原子性：指的是一个事务中，要么全都执行，要么全部不执行。对于redis事务来讲，事务队列中的命令要么全部执行，要么全部不执行，因此具有原子性。但是redis事务不支持事务回滚机制，即使事务队列某个命令在执行期间出现了错误，整个事务还是会执行下去。
        2）一致性：事务一致性指的是数据库执行事务之前是一致的，执行之后也是一致的。一致指的是数据符合数据库本身的定义和要求，没有包含非法或无效的错误数据。
            1、入队错误：事务在入队命令过程中，命令不存在，或者格式不正确，热地说将拒绝执行事务。
            2、执行错误：除了入队发生错误，事务还可能在执行过程中发生错误。比如键的类型错误等。出错的命令会在执行中识别出来，不会对事务的一致性产生任何影响。
            3、服务器停机：服务器不管处于哪种持久化模式下，停机恢复之后，都不影响一致性。
        3）隔离性：指的是数据库并发执行时，事务之间不会相互影响，因为redis都是单线程执行，所以具有隔离性。
        4）耐久性：当服务器运行在aof持久化模式，并且apeendfsync选项的值为always时，事务具有耐久性。


3、lua脚本
    LongPollingService


4、排序
    sort命令可以对列表键、集合键或者有序集合键的值进行排序。
    1）alpha选项：sort <key> alpha, 通过alpha选项，sort命令可以对包含字符串值的键进行排序
    2）asc选项和desc选项：默认情况下是升序排序，排序后结果按值的大小从小到大。sort <key> asc(asc可不要)，降序就要desc，命令是：sort <key> desc
    3）by选项：通过by选项，sort命令可以指定某些字符串键或某个哈希键所包含某些字段来作为元素的权重。例如：mset apple-price 8 banana-price 5.5 cherry-price 7。 sort fruits by *-price
    4) limit选项：limit <offset> <count> 命令执行。例如 sort alphabet alpha limit 0 4.
    5）store选项：默认情况下sort命令只返回排序结果，不保存排序结果，通过store选项，可以保存指定结果，如sort students alpha store sorted_students,  lrange sorted_students 0 -1

5、二进制位数组
    redis提供了setbit、getbit、bitcount、bitop四个命令用于处理二进制位数组。例如setbit bit 0 1 #0000 0001，setbit bit 3 1 #0000 1001, getbit bit 0 #返回1，bitcount统计位数组里面，值为1的二进制位数量。bitop命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算。
    1）位数组表示：redis使用字符串对象表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的。buf数组每个字节有8个位，并且是通过逆序来保存位数组，可以简化setbit命令的实现。
    2）getbit命令实现：用于返回位数组在offset偏移量上的二进制位。先计算byte=offset/8，算出在哪个字节上，然后再算bit=(ofset mod 8) + 1,在第几个二进制位上。复杂度O(1).
    3) setbit命令实现：用于将位数组在offset偏移量上的二进制位值设置为value。在需要对数组的长度进行扩容时，SDS的空间预分配策略会额外的多分配相关自己的未使用空间。这样后续有新入的二进制位直接写进去就好了，注意buf数组之前提到过是用逆序保存位数组的，所以直接写就好了，如果是正序，每次扩展的时候，程序都需要将先前的位移动了之后在写入，这样对cpu不是特别友好。
    4）bigcount统计算法：第一个：遍历算法，最简单直接的方法，效率非常低。第二个：查表算法，创建一张表，然后把每个字节分别存起来，然后统计每个字节的含1的个数，这样效率提升了8倍，但是还是效率有问题。如果要创建更大的表，就要考虑内存和缓存两方面因素。第三种：variable-precision-SWAP算法（计算汉明重量）：先两个二进制位一组，计算汉明重量，然后4个二进制位为一组计算汉明重量，在八个一组计算重量，最后最高八位，然后右移24位。redis二进制位小于128位使用查表，大于128位使用汉明重量。


6、慢查询日志
    redis慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可根据着监视和优化。slowlog-log-slower-than配置选项






滴滴面试相关题：分布式缓存
1、缓存雪崩
    1）原因：原有缓存失效，新请求到达后全部查数据库，对数据产生压力，造成宕机。
    2）处理方案：第一是并发量不多时，可以采用加锁排队。第二是给每一个缓存增加相应的缓存标记，记录缓存是否失效，则更新数据缓存。第三是为key设置不同的缓存失效时间。

2、缓存穿透
    1）原因：用户查询数据不存在，一直打在数据库，导致缓存不命中。
    2）处理方案： 常见的采用布隆过滤器，将可能存在数据放到足够大的bitmap中，不存在的数据就会被bitmap拦截，避免查询系统压力。还有简单点，就是查询为空的数据也给他缓存一个值，这样第二次进来时就能获取返回的空。



其他面试：
数据库分库分表应关注的问题
1、分片键和分片规则选取的问题
2、如何避免所有库扫描问题
3、分库分表中间件选择的问题
4、分布式全局唯一id问题
5、跨库join问题
6、跨库事务问题
7、跨库排序分页问题
8、数据迁移扩容问题


sharding-jdbc这种client层方案优点在于不用部署，运维成本低，不需要代理层做二次转发，性能较高，但是升级时需要各个系统重新升级版本在发布，各个系统都需要耦合sharding-jdbc
mycat这种proxy层方案缺点在于需要部署，自己运维一套中间件，运维成本高，好处就是项目透明，升级时只需在对应中间件处理就行了。

















3