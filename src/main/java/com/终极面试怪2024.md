java基础：
1、**java中基本类型为什么还需要包装类**
    在使用集和类中，我们无法将int、double等基本类型放入集和中，因为要求的是object类型，所以为了让基本类型也有对象的特征，并为其添加属性和方法，丰富操作。他们两区别在于01：默认值
不同，02：初始方式不同 03：存储方式不同，基本类型存储在栈上，包装类型存储在堆上。包装类还有自动拆箱和装箱功能，其实就是通过包装类中valueOf()方法实现。integer包装类将-128 ~ 127缓存起来

2、**为什么不能用浮点数表示金额**
    因为不是所有小数都能用二进制表示，比如0.1,0.1的二进制会出现无限循环的情况，所以IEEE规范剔除了一种使用近似值表示小数的方式，引入了精度的概念，这就是浮点数。0.1+0.2 != 0.3

3、**为什么不能用bigDecimal的equals方法做等值比较**
    bigDecimal里面有两个属性，value和标度（scale），在使用equals时，不仅会比较值，还会比较精度scale，对于0.1和0.10，值一样，精度不一样，使用equals就返回false。推荐使用compareTo，
bigDecimal(double)中，因为double自身表示的是一个近似值，所以创建出来的值比如new BigDecimal(0.1)并不是0.1

4、**BigDecimal中的应用，如何实现的精确计数**
    里面有一个无标度值（intVal，实际值）和标度（scale，表示小数点后的位数），一个数值为123.45，无标度值就是12345，scale就为2。123.45 = 12345 * 10^(-2)，标度为负数时，往左移对应位数

5、**java中的负数取绝对值一定是正数嘛？**
    Math.abs(intVal), 假如intval传入的是-2145483648=-2^31，取绝对值后应该是2145483648，但是这个超出了int的最大范围，俗称越界，这个时候值math.abd(-2145483648) = -1。并且
发生越界问题时不会报错的，所以开发时需注意。

6、**string、stringBuilder、stringBuffer的区别**
    string是不可变的，stringBuilder和stringBuffer是可变的，Buffer是线程安全的，而builder是非线程安全的。string为什么设置为不可变性，主要是从缓存、安全性、线程安全和性能角度出发。
缓存：字符串使用时最为广泛的，所以大量字符串是非常耗资源，java提供了一个字符串池，增加其缓存功能，节省空间。安全性：字符串还经常用于存储账号密码登敏感信息，所以字符串的内容是不可变的，
就可以相信这个字符串。并string是线程安全的，线程访问时都为同一个。builder和Buffer里面也是数组char[],不过不是final修饰的，并且这个数组长度不是所有位置都已经被使用，因为append中会扩容。
Buffer就是每个方法加上synchronized。不要再for循环中使用 **+** 拼接字符串，因为它是语法糖，在反编译后其实是new stringBuilder().append(str);

7、**string是如何保证不可变性**
    1、string类被声明为final，不能被继承，里面方法无法被覆盖 2、用final修饰字符串内容char[],一旦被初始化，就不能指向其他数组 3、string类没有提供用于修改字符串的公共方法，如果是修改
只会创建一个新的string对象。string的长度限制分为编译期和运行期，编译期间用constant_utf8_info表示字符串常量的值，限制是65535，运行期间length参数是int类型，所以最大长度是2 ^ 31 - 1。

8、**string str = new string("hollis")创建了几个对象？**
    创建对象数应该是1个或者2个，首先在new的过程中，都会在堆上创建一个对象，至于另外一个对象，就看具体情况。另外一个对象就是常量池中的字符串常量，如果是第一次执行，同时会创建两个对象，一个是
字符串常量引用的对象，另一个是我们new出来的，如果不是第一次执行，就会创建我们new出来的。

9、**什么是SPI，与api有啥区别**
    API直接被应用开发人员使用，SPI被框架扩展人员使用，APi用于定义调用接口，而SPI用于定义和提供可插拔的实现方式。spi的应用场景：调用这根据实际使用需要，启用、扩展或者替换框架的实现策略。
比如01：数据库驱动加载接口实现类的加载 02：jdbc加载不同类型数据库的驱动 03：日志门面接口实现类加载

10、**反射机制是什么，为什么反射慢**
    反射机制指的是运行时能够获取自身信息。java的反射可以判断一个对象所属的类、成员变量、方法、调用方法等。反射的好处就是可以提升程序的灵活性和扩展性。但是缺点就是：01：代码可读性及可维护性
变低，02：反射代码执行的性能低 03：反射破坏了封装性。之所以慢是因为：01：涉及动态解析的类型，不能执行jvm优化，如jit优化 02：反射使用时参数需要从object[]拆包，过程中可能会产生很多对象，容易
gc。 03：反射调用时会编码从方法数组中查找，检查可见性，都是耗时的 04：使用反射参数时有额外检查

11、**如何破坏单例模式**
    使用反射或使用反序列化都可以破坏单例模式，反射中setAccessible(true)后，使得反射对象使用时取消java语言访问检查，私有的构造函数能被访问。反序列化中会通过unsafe直接分配内存的方式
创建一个新对象。如何避免破坏单例模式：反射方式破坏时，在构造函数加判断，singleton！=null的情况，反序列化破坏时，定义readResolve方法，返回当前对象，因为反序列判断时，会有一个判断，
如果实现了serializable方法，包含readResolve方法时，直接返回true。

12、java的动态代理如何实现
    jdk动态代理：reflect包中的proxy类和InvocationHandler接口提供了生成动态代理类的能力。cglib动态代理：cglib是一个三方类库，运行时动态生成子类对象从而实现目标功能的扩展。jdk动态代理
的对象必须实现一个或多个接口，不然使用cglib实现。主要应用在各个框架，如aop、过滤器、拦截器等

13、fastjson的反序列化漏洞
    在最前版本时，如果一个类包含接口或抽象类，在进行序列化时会抹去子类型，导致反序列时拿不到原始类型。后续引入了autoType，就是序列化时记录原始类型，结果黑客利用这个特性，假如@type反序列化
相关对象，对相关类实现攻击。

14、
    

