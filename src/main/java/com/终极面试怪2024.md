`java基础`：

1、**`java中基本类型为什么还需要包装类`**
    在使用集和类中，我们无法将int、double等基本类型放入集和中，因为要求的是object类型，所以为了让基本类型也有对象的特征，并为其添加属性和方法，丰富操作。他们两区别在于01：默认值
不同，02：初始方式不同 03：存储方式不同，基本类型存储在栈上，包装类型存储在堆上。包装类还有自动拆箱和装箱功能，其实就是通过包装类中valueOf()方法实现。integer包装类将-128 ~ 127缓存起来

2、**`为什么不能用浮点数表示金额`**
    因为不是所有小数都能用二进制表示，比如0.1,0.1的二进制会出现无限循环的情况，所以IEEE规范剔除了一种使用近似值表示小数的方式，引入了精度的概念，这就是浮点数。0.1+0.2 != 0.3

3、**`为什么不能用bigDecimal的equals方法做等值比较`**
    bigDecimal里面有两个属性，value和标度（scale），在使用equals时，不仅会比较值，还会比较精度scale，对于0.1和0.10，值一样，精度不一样，使用equals就返回false。推荐使用compareTo，
bigDecimal(double)中，因为double自身表示的是一个近似值，所以创建出来的值比如new BigDecimal(0.1)并不是0.1

4、**`BigDecimal中的应用，如何实现的精确计数`**
    里面有一个无标度值（intVal，实际值）和标度（scale，表示小数点后的位数），一个数值为123.45，无标度值就是12345，scale就为2。123.45 = 12345 * 10^(-2)，标度为负数时，往左移对应位数

5、**`java中的负数取绝对值一定是正数嘛`？**
    Math.abs(intVal), 假如intval传入的是-2145483648=-2^31，取绝对值后应该是2145483648，但是这个超出了int的最大范围，俗称越界，这个时候值math.abd(-2145483648) = -1。并且
发生越界问题时不会报错的，所以开发时需注意。

6、**`string、stringBuilder、stringBuffer的区别`**
    string是不可变的，stringBuilder和stringBuffer是可变的，Buffer是线程安全的，而builder是非线程安全的。string为什么设置为不可变性，主要是从缓存、安全性、线程安全和性能角度出发。
缓存：字符串使用时最为广泛的，所以大量字符串是非常耗资源，java提供了一个字符串池，增加其缓存功能，节省空间。安全性：字符串还经常用于存储账号密码登敏感信息，所以字符串的内容是不可变的，
就可以相信这个字符串。并string是线程安全的，线程访问时都为同一个。builder和Buffer里面也是数组char[],不过不是final修饰的，并且这个数组长度不是所有位置都已经被使用，因为append中会扩容。
Buffer就是每个方法加上synchronized。不要再for循环中使用 **+** 拼接字符串，因为它是语法糖，在反编译后其实是new stringBuilder().append(str);

7、**`string是如何保证不可变性`**
    1、string类被声明为final，不能被继承，里面方法无法被覆盖 2、用final修饰字符串内容char[],一旦被初始化，就不能指向其他数组 3、string类没有提供用于修改字符串的公共方法，如果是修改
只会创建一个新的string对象。string的长度限制分为编译期和运行期，编译期间用constant_utf8_info表示字符串常量的值，限制是65535，运行期间length参数是int类型，所以最大长度是2 ^ 31 - 1。
jdk9中把string的char[]改为了byte[],这是因为java内部使用utf-16每个char占据两个字节，即使某些字符用一个字节表示，仍会占用两个字节。所以引入了compact string概念，源码中还有个coder，0表示
Latin1编码格式，1表示utf-16格式。

8、**`string str = new string("hollis")创建了几个对象？`**
    创建对象数应该是1个或者2个，首先在new的过程中，都会在堆上创建一个对象，至于另外一个对象，就看具体情况。另外一个对象就是常量池中的字符串常量，如果是第一次执行，同时会创建两个对象，一个是
字符串常量引用的对象，另一个是我们new出来的，如果不是第一次执行，就会创建我们new出来的。

9、**`什么是SPI，与api有啥区别`**
    API直接被应用开发人员使用，SPI被框架扩展人员使用，APi用于定义调用接口，而SPI用于定义和提供可插拔的实现方式。spi的应用场景：调用这根据实际使用需要，启用、扩展或者替换框架的实现策略。
比如01：数据库驱动加载接口实现类的加载 02：jdbc加载不同类型数据库的驱动 03：日志门面接口实现类加载

10、**`反射机制是什么，为什么反射慢`**
    反射机制指的是运行时能够获取自身信息。java的反射可以判断一个对象所属的类、成员变量、方法、调用方法等。反射的好处就是可以提升程序的灵活性和扩展性。但是缺点就是：01：代码可读性及可维护性
变低，02：反射代码执行的性能低 03：反射破坏了封装性。之所以慢是因为：01：涉及动态解析的类型，不能执行jvm优化，如jit优化 02：反射使用时参数需要从object[]拆包，过程中可能会产生很多对象，容易
gc。 03：反射调用时会编码从方法数组中查找，检查可见性，都是耗时的 04：使用反射参数时有额外检查

11、**`如何破坏单例模式`**
    使用反射或使用反序列化都可以破坏单例模式，反射中setAccessible(true)后，使得反射对象使用时取消java语言访问检查，私有的构造函数能被访问。反序列化中会通过unsafe直接分配内存的方式
创建一个新对象。如何避免破坏单例模式：反射方式破坏时，在构造函数加判断，singleton！=null的情况，反序列化破坏时，定义readResolve方法，返回当前对象，因为反序列判断时，会有一个判断，
如果实现了serializable方法，包含readResolve方法时，直接返回true。

12、**`java的动态代理如何实现`**
    jdk动态代理：reflect包中的proxy类和InvocationHandler接口提供了生成动态代理类的能力。cglib动态代理：cglib是一个三方类库，运行时动态生成子类对象从而实现目标功能的扩展。jdk动态代理
的对象必须实现一个或多个接口，不然使用cglib实现。主要应用在各个框架，如aop、过滤器、拦截器等

13、**`fastjson的反序列化漏洞`**
    在最前版本时，如果一个类包含接口或抽象类，在进行序列化时会抹去子类型，导致反序列时拿不到原始类型。后续引入了autoType，就是序列化时记录原始类型，结果黑客利用这个特性，假如@type反序列化
相关对象，对相关类实现攻击。

14、**`什么是AIO、BIO、NIO`**
    BIO:同步阻塞IO，线程发起io请求时，一直阻塞，知道缓冲区就绪。AIO：同步非阻塞IO，线程发起io请求，不需要阻塞，用户线程不需要原地等待，先做其他操作，只需定时轮询检查io缓冲区是否就绪。
AIO:异步非阻塞IO模型，发起io请求，不阻塞，也不定时轮询，异步io回调通知。

15、**`java是值传递还是引用传递`**
    值传递和引用传递最大的区别是传递过程中有没有复制一个副本来传递，如果是副本，就是值传递，否则就是引用传递，java对象传递，是通过复制的方式把引用关系传递了，因为有复制的过程，所以是值传递。只不过
传递的内容是对象的应用。

16、**`深拷贝和浅拷贝`**
    浅拷贝指将一个对象复制到另外一个变量中，只复制对象的地址，而不是对象本身，原始对象和复制对象实际上共享同一个内存地址。java中beanUtils基本是浅拷贝。好处就是性能好，没有复杂对象时考虑用浅拷贝。
深拷贝指将一个对象及其所有子对象复制到另一个变量中，创建一个全新对象。不共享，修改后不受影响，深拷贝需要实现cloneable接口，重写clone方法。还是使用序列化的方式实现深拷贝，比如fastjson，或者实现
Serializable接口后使用SerializationUtils.clone

17、**`Arrays.sort采用什么排序方式`**
    根据参数类型的不同，提供了不同的排序方式，对于int、double、char等数据排序，使用双轴快速排序，而对对象数组的排序方式，使用归并排序和timSort

18、**`final、finally、finalize区别`**
    final用于声明、方法或类，使之不可变、不可重写或不可继承。finally：用异常处理的一部分，用于确保代码块执行总是执行。finalize：object的一个方法
用于对象被垃圾回收前执行清理操作，不推荐使用。

19、**有了equals为啥需要hashcode方法**
    equals和hashcode通常都是成对的，equals用于判断两个对象是否相等，hashCode是生成对象的哈希码，确定在哈希标的位置。equals比较两对象是相等的，他们的hashcode必须返回相同值。对于要有
hashcode，一方面是效率，快速计算在哈希表的位置，一方面是保证数据的一致性和准确性。

20、**`stream并行流一定比串行流快嘛`？**
    不一定，stream底层使用forkJoin并行处理，当并行处理的时候,线程管理的开销、任务分割、线程争用、数据依赖性、环境配置。一般单核cpu下，串行比并行效率还高，多核cpu下，如果元素数量比较少，
串行也比并行好。

`集和类冲冲`

21、**`Java集和类有哪些`**
    分为五类：list、set、queue、stack、map，继承关系来讲，前三种是collection的子接口，表示可循环。功能上讲：list是一个容器，可以先进先出，也可先进后出。set是无序的，同时不重复，他会根据
equals、compareTo、hashCode比较，list分为有链表和数据实现，链表增删快、数组查询快。queue分为优先队列、双端队列等。map分为hashMap和排序的treeMap。

24、**`arrayList、linkedList、vector区别`**
    都实现了list接口，功能相似。arrayList是一个可改变大小的数组，大小可动态增加，本质上就是一个数组。linkedList是一个双向链表，添加和删除时有更好的性能，get和set方面稍弱。vector强同步
里面是线程安全的，这也导致其性能问题，arrayList初始化容量为10，比较小，可以预估数量的前提下建议分配一个初始化值，减少扩容的开销。vector扩容是两倍扩，arrayList是1.5倍

25、**`arrayList序列化是怎么实现的`**
    arrayList底层通过object数据完成，被声明了transient,在默认的序列化策略中并没有序列化数组字段。为了避免Java自带序列化机制造成空间浪费，所以把数组定义了transient，并且重写writeObject
和readObject来实现序列化操作

26、**`hash冲突怎么解决`**
    常见五种方案：01：开放定址法（一旦发生冲突，就去寻找下一个空的散列地址，直到找到空的将记录存下，常见的有线性探测、二次探测、双重散列，缺点就是聚集问题，降低性能）02：链地址法（最常用解决hash冲突，
每个bucket 指向一个链表，冲突时加到链表末尾，Java8就是用这个解决hash冲突，超过阈值后转红黑树）03：在哈希法，冲突时再次计算另一个hash函数，知道冲突不发生为止，需要额外的计算。04：建立公共溢出
区（建立溢出表，冲突的数据放进去））05：一致性hash（将数据均匀分布到多个节点减少冲突，常用于分布式系统，如果redis集群）

27：**`能讲讲hashmap嘛？`**
    首先，hashmap是基于数组加链表的方式实现的，通过计算hashCode的方式找到对应数组下标，如果发生hash冲突，就放到链表中，且超出阈值后转为红黑树。它并不是线程安全的，并且key可以允许为null，默认
的初始容为16，超过75%后进行扩容，扩大至原先两倍，然后重新分配。   其中获取元素是get方法：他会经过hash后计算数组的位置，然后查找对应数组或链表是否有对应值。插入元素使用的是put方法：先计算hash值，找到索引
位置，如果为空，插入，不为空，跟键值对比较，相等就替换，不相等就插入到链表中或红黑树中，成功返回成功，失败返回null，成功后如果需要扩容，进行一次扩容操作。

28、**`hashMap如何定位hash位置的？`**
    首先计算hash函数时使用(key.hashCode ^ (key.hashCode >> 16))，这里是个扰动函数，高16位和低16位进行异或操作，得到扰动后的hashCode，这样做是让hash尽可能分散一点。然后再put时
在通过(table.length - 1) & (扰动函数后的hashcode)得到对应的位置，这里相当于 (扰动函数后的hashcode) % 2^n,只不过二进制比10进制运算快。并且如果key为null，做了一个特殊处理，
总是放在数组的第一个元素中。

29、**`hashMap如何保证长度2的n次方？为什么默认负载因子为0.75？`**
    长度为2的n次方是为了保证取模运算的时候进行位运算，因为直接用%取模要转成10进制，为了提高效率直接 & 上2^n-1，前提是2的n次方。所以在初始化和扩容的时候，默认16，如果初始化了对应长度，它会自动计算为
2的n次方。负载因子设置为0.75，刚好为3/4,然后临界值计算方式为 临界值=负载因子 * 容量（默认16），这个是经过计算的，如果太大会导致大量的hash冲突，太小又会浪费空间，0.75怎么乘都能保证是整数。在阿里开发
手册里面建议设置初始化大小，这个大小最好是 (初始大小 / 0.75 + 1)

30、**`hashMap如何扩容的？为什么要转红黑树？`**
    当put的时候判断size+1后判断>临界值，大于就扩容，分三个不分01：如果桶节点没有链表，直接rehash到其他桶。02：如果桶有链表，重新链接后统一移动，不用一个个节点rehash。03：链表形成红黑树，
元素小于6时，取消树化操作。 之所以选择红黑树，就是因为在bucket冲突多时，链表会变得比较长，复杂度为o(n)。 所以需要一个东西替代链表，二叉树就是比较好的选择，不过
二叉树最坏情况可能会退化成链表，二叉平衡树因为要严格保证高度差，所以插入和修改时较为耗时。红黑树在自平衡的同时，插入最多两次旋转，删除最多三次。基于综合情况，选择红黑树

31、**`concurrentHashMap是如何保证线程安全|`**
    jdk7使用分段锁的技术，及默认分了16个段，每个段独立的锁，这样多个线程同时访问时，只需要锁住相关段即可（但是在高并发的情况下，仍然出现锁竞争，导致性能下降）。
jdk8使用节点锁思想，采用cas+synchronized，如果某个段为空，就使用cas操作添加新节点，不为空则使用synchronized锁住当前段，再次尝试put。这样可以避免锁力度太大，
以及过多锁竞争问题。

31、


**方法区是如何实现的？**
方法区是Java虚拟机规范定义的一块存储类信息、常量、静态变量、编译器编译后的代码等数据内存区域。jdk7之前，方法区被叫做永久代。1.6的时候包含字符串常量池，不过1.7之后放到堆内存中了。
1.8之后方法区又叫做元空间，是直接使用本地内存存储，不在位于堆中。字符串常量池是在编译时放入常量池中，是Java的一块特殊内存区域。字符串常量池数据有两个来源，字面量常量，intern方法
    

