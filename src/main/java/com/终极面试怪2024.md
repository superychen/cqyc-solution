`java基础`：

1、**`java中基本类型为什么还需要包装类`**
    在使用集和类中，我们无法将int、double等基本类型放入集和中，因为要求的是object类型，所以为了让基本类型也有对象的特征，并为其添加属性和方法，丰富操作。他们两区别在于01：默认值
不同，02：初始方式不同 03：存储方式不同，基本类型存储在栈上，包装类型存储在堆上。包装类还有自动拆箱和装箱功能，其实就是通过包装类中valueOf()方法实现。integer包装类将-128 ~ 127缓存起来

2、**`为什么不能用浮点数表示金额`**
    因为不是所有小数都能用二进制表示，比如0.1,0.1的二进制会出现无限循环的情况，所以IEEE规范剔除了一种使用近似值表示小数的方式，引入了精度的概念，这就是浮点数。0.1+0.2 != 0.3

3、**`为什么不能用bigDecimal的equals方法做等值比较`**
    bigDecimal里面有两个属性，value和标度（scale），在使用equals时，不仅会比较值，还会比较精度scale，对于0.1和0.10，值一样，精度不一样，使用equals就返回false。推荐使用compareTo，
bigDecimal(double)中，因为double自身表示的是一个近似值，所以创建出来的值比如new BigDecimal(0.1)并不是0.1

4、**`BigDecimal中的应用，如何实现的精确计数`**
    里面有一个无标度值（intVal，实际值）和标度（scale，表示小数点后的位数），一个数值为123.45，无标度值就是12345，scale就为2。123.45 = 12345 * 10^(-2)，标度为负数时，往左移对应位数

5、**`java中的负数取绝对值一定是正数嘛`？**
    Math.abs(intVal), 假如intval传入的是-2145483648=-2^31，取绝对值后应该是2145483648，但是这个超出了int的最大范围，俗称越界，这个时候值math.abd(-2145483648) = -1。并且
发生越界问题时不会报错的，所以开发时需注意。

6、**`string、stringBuilder、stringBuffer的区别`**
    string是不可变的，stringBuilder和stringBuffer是可变的，Buffer是线程安全的，而builder是非线程安全的。string为什么设置为不可变性，主要是从缓存、安全性、线程安全和性能角度出发。
缓存：字符串使用时最为广泛的，所以大量字符串是非常耗资源，java提供了一个字符串池，增加其缓存功能，节省空间。安全性：字符串还经常用于存储账号密码登敏感信息，所以字符串的内容是不可变的，
就可以相信这个字符串。并string是线程安全的，线程访问时都为同一个。builder和Buffer里面也是数组char[],不过不是final修饰的，并且这个数组长度不是所有位置都已经被使用，因为append中会扩容。
Buffer就是每个方法加上synchronized。不要再for循环中使用 **+** 拼接字符串，因为它是语法糖，在反编译后其实是new stringBuilder().append(str);

7、**`string是如何保证不可变性`**
    1、string类被声明为final，不能被继承，里面方法无法被覆盖 2、用final修饰字符串内容char[],一旦被初始化，就不能指向其他数组 3、string类没有提供用于修改字符串的公共方法，如果是修改
只会创建一个新的string对象。string的长度限制分为编译期和运行期，编译期间用constant_utf8_info表示字符串常量的值，限制是65535，运行期间length参数是int类型，所以最大长度是2 ^ 31 - 1。
jdk9中把string的char[]改为了byte[],这是因为java内部使用utf-16每个char占据两个字节，即使某些字符用一个字节表示，仍会占用两个字节。所以引入了compact string概念，源码中还有个coder，0表示
Latin1编码格式，1表示utf-16格式。

8、**`string str = new string("hollis")创建了几个对象？`**
    创建对象数应该是1个或者2个，首先在new的过程中，都会在堆上创建一个对象，至于另外一个对象，就看具体情况。另外一个对象就是常量池中的字符串常量，如果是第一次执行，同时会创建两个对象，一个是
字符串常量引用的对象，另一个是我们new出来的，如果不是第一次执行，就会创建我们new出来的。

9、**`什么是SPI，与api有啥区别`**
    API直接被应用开发人员使用，SPI被框架扩展人员使用，APi用于定义调用接口，而SPI用于定义和提供可插拔的实现方式。spi的应用场景：调用这根据实际使用需要，启用、扩展或者替换框架的实现策略。
比如01：数据库驱动加载接口实现类的加载 02：jdbc加载不同类型数据库的驱动 03：日志门面接口实现类加载

10、**`反射机制是什么，为什么反射慢`**
    反射机制指的是运行时能够获取自身信息。java的反射可以判断一个对象所属的类、成员变量、方法、调用方法等。反射的好处就是可以提升程序的灵活性和扩展性。但是缺点就是：01：代码可读性及可维护性
变低，02：反射代码执行的性能低 03：反射破坏了封装性。之所以慢是因为：01：涉及动态解析的类型，不能执行jvm优化，如jit优化 02：反射使用时参数需要从object[]拆包，过程中可能会产生很多对象，容易
gc。 03：反射调用时会编码从方法数组中查找，检查可见性，都是耗时的 04：使用反射参数时有额外检查

11、**`如何破坏单例模式`**
    使用反射或使用反序列化都可以破坏单例模式，反射中setAccessible(true)后，使得反射对象使用时取消java语言访问检查，私有的构造函数能被访问。反序列化中会通过unsafe直接分配内存的方式
创建一个新对象。如何避免破坏单例模式：反射方式破坏时，在构造函数加判断，singleton！=null的情况，反序列化破坏时，定义readResolve方法，返回当前对象，因为反序列判断时，会有一个判断，
如果实现了serializable方法，包含readResolve方法时，直接返回true。

12、**`java的动态代理如何实现`**
    jdk动态代理：reflect包中的proxy类和InvocationHandler接口提供了生成动态代理类的能力。cglib动态代理：cglib是一个三方类库，运行时动态生成子类对象从而实现目标功能的扩展。jdk动态代理
的对象必须实现一个或多个接口，不然使用cglib实现。主要应用在各个框架，如aop、过滤器、拦截器等

13、**`fastjson的反序列化漏洞`**
    在最前版本时，如果一个类包含接口或抽象类，在进行序列化时会抹去子类型，导致反序列时拿不到原始类型。后续引入了autoType，就是序列化时记录原始类型，结果黑客利用这个特性，假如@type反序列化
相关对象，对相关类实现攻击。

14、**`什么是AIO、BIO、NIO`**
    BIO:同步阻塞IO，线程发起io请求时，一直阻塞，知道缓冲区就绪。AIO：同步非阻塞IO，线程发起io请求，不需要阻塞，用户线程不需要原地等待，先做其他操作，只需定时轮询检查io缓冲区是否就绪。
AIO:异步非阻塞IO模型，发起io请求，不阻塞，也不定时轮询，异步io回调通知。

15、**`java是值传递还是引用传递`**
    值传递和引用传递最大的区别是传递过程中有没有复制一个副本来传递，如果是副本，就是值传递，否则就是引用传递，java对象传递，是通过复制的方式把引用关系传递了，因为有复制的过程，所以是值传递。只不过
传递的内容是对象的应用。

16、**`深拷贝和浅拷贝`**
    浅拷贝指将一个对象复制到另外一个变量中，只复制对象的地址，而不是对象本身，原始对象和复制对象实际上共享同一个内存地址。java中beanUtils基本是浅拷贝。好处就是性能好，没有复杂对象时考虑用浅拷贝。
深拷贝指将一个对象及其所有子对象复制到另一个变量中，创建一个全新对象。不共享，修改后不受影响，深拷贝需要实现cloneable接口，重写clone方法。还是使用序列化的方式实现深拷贝，比如fastjson，或者实现
Serializable接口后使用SerializationUtils.clone

17、**`Arrays.sort采用什么排序方式`**
    根据参数类型的不同，提供了不同的排序方式，对于int、double、char等数据排序，使用双轴快速排序，而对对象数组的排序方式，使用归并排序和timSort

18、**`final、finally、finalize区别`**
    final用于声明、方法或类，使之不可变、不可重写或不可继承。finally：用异常处理的一部分，用于确保代码块执行总是执行。finalize：object的一个方法
用于对象被垃圾回收前执行清理操作，不推荐使用。

19、**有了equals为啥需要hashcode方法**
    equals和hashcode通常都是成对的，equals用于判断两个对象是否相等，hashCode是生成对象的哈希码，确定在哈希标的位置。equals比较两对象是相等的，他们的hashcode必须返回相同值。对于要有
hashcode，一方面是效率，快速计算在哈希表的位置，一方面是保证数据的一致性和准确性。

20、**`stream并行流一定比串行流快嘛`？**
    不一定，stream底层使用forkJoin并行处理，当并行处理的时候,线程管理的开销、任务分割、线程争用、数据依赖性、环境配置。一般单核cpu下，串行比并行效率还高，多核cpu下，如果元素数量比较少，
串行也比并行好。

`集和类冲冲`

21、**`Java集和类有哪些`**
    分为五类：list、set、queue、stack、map，继承关系来讲，前三种是collection的子接口，表示可循环。功能上讲：list是一个容器，可以先进先出，也可先进后出。set是无序的，同时不重复，他会根据
equals、compareTo、hashCode比较，list分为有链表和数据实现，链表增删快、数组查询快。queue分为优先队列、双端队列等。map分为hashMap和排序的treeMap。

22、**`Java集和类有哪些`**
    


**方法区是如何实现的？**
方法区是Java虚拟机规范定义的一块存储类信息、常量、静态变量、编译器编译后的代码等数据内存区域。jdk7之前，方法区被叫做永久代。1.6的时候包含字符串常量池，不过1.7之后放到堆内存中了。
1.8之后方法区又叫做元空间，是直接使用本地内存存储，不在位于堆中。字符串常量池是在编译时放入常量池中，是Java的一块特殊内存区域。字符串常量池数据有两个来源，字面量常量，intern方法
    

