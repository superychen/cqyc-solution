#MQ开始了哦
###先讲RocketMQ
1、**`RocketMQ事务消息如何实现？`**
    rocketMQ的事务消息通过TransactionListener接口实现。
    整个流程：01、先给Broker发送一条half半消息，half消息存储在broker端中，此时不会发送给消费者（标记为prepared状态）。 02、half消息发送给消息发送方（也就是生产者）
        03、生产收到half消息后提交本地事务，并发送commit或者rollback消息。 04、rocketMQ接收到反馈后，rollback就回滚该事物，提交就将消息还原成原始消息，传给消费者。
        04、消费者消费消息（如果消费失败，则会重试，直到最终一致性）
    问题点：01：如果生产者收到half消息后，broker一直收不到commit或者rollback怎么办？
        答：如果在规定时间内没收到，rocketMQ会向应用程序发送一条检查请求，看回调方法是否能收到该事务消息，如果应用程序还是在规定时间未响应，标记为unknow状态。标记unknow状态的消息，
            如果应用程序有结果，还可以向MQ发送commit或者rollback。但如果超过72小时，mq会自动回滚该事务消息。
        02：第一次发送half消息失败怎么办？答：重试
        03：为什么要用事务消息？答：本地事务执行完成后发送消息可能会发送失败，消费者无法处理，导致数据不一致。有了这个可以保证数据一致性。

2、**`RocketMQ如何保证消息顺序性？`**
    01：概念：它只支持在同一个队列内消息能做到有序性，不同queue中的消息是无序的。如果想要发送顺序消息，在send方法中，传入MessageQueueSelector。（在里面需要实现select方法，然后指定到那个messageQueue）。
    02：如何保证消费者有序消费：发送到同一队列后，消费者通过有序消费模式MessageListenerOrderly实现，这个实现里面通过三把锁保证顺序消费，
            第一把锁（确保消息只会投递到同一消费者）：保证同一个队列的有序消息可以被顺序消费，broker就只会把消息发到同一个消费者上，这时就需要加第一把锁，在consumeMessageOrderlyService初始化时，启动一个定时任务，
                尝试向broker为当前消费者客户端申请分布式锁。获取成功后后续消息就只发给这个消费者。
            第二把锁（对messageQueue加锁，确保只有一个线程处理这个消息队列）：消息拉取时，消费者会一次性拉取多条消息，放入ProcessQueue，然后提交到消费线程池。为保证顺序消费，所以一个队列只能
                一个线程处理队列消息。
            第三把锁（processQueue加锁确保重平衡过程中不会出现重复消费）：获取到第二把锁后，就可以从processQueue依次拉取一批消息处理，为保证消息不重复消费，需要对processQueue加锁。
    03：为什么需要第三把锁？ 答：为了重平衡，如果新增消费者，发生重平衡，比如队列原来属于客户端A消费，现在重新分配给客户端B去消费，可能存在一部分数据重复消费，所以对processQueue加锁。
    04：顺序消费存在的问题：这三把锁的方式可能会降低系统吞吐量，而且出现消息阻塞的话，可能会达到系统瓶颈。

3、**`RocketMQ如何保证消息不丢失？`**
    想要确保不丢失，需要生产者、broker、消费者的共同协作，缺一不可
    01、首先在生产者端，消息的发送分为**同步发和异步发**，同步发会阻塞等待Broker返回结果，如果这个时候出现异常，发送失败，则进行重试。异步发送需要生产者重写sendCallback中的方法，
        用于broker端回调，在方法中确认消息是成功投递还是需要进行重试。
    02、在broker端，在接收消息后刷盘的操作分为**同步刷盘和异步刷盘**，默认是异步，他会先将消息存储到内存中，也就是page cache中，这个时候就会将确认结果发给生产者，
        如果这时出现page cache还未刷到磁盘就宕机的情况，消息就会丢失。这种可以设置为同步刷盘，直到刷盘成功才确认消息。
    03、broker部署的时候保证高可用也可提高消息可靠性，这时rocketMQ可以采用集群的方式部署，可采用**一主多从**的部署方式，并利用主从同步的方式进行数据复制。当主节点宕机时，
        也可从从节点获取消息。异步复制问题点：默认使用异步复制的方式，如果写入master成功后，然后master确认响应给消费者，这个消息会复制到从节点，但是此时master宕机或
            磁盘损坏，这样会导致消息丢失。
           所以解决这个问题，可以配置同步复制的方式，即master同步给从节点在返回给生产者确认消息。
    04、消费者端 确保消息拉取并消费成功后给Broker返回ACK，如果broker没收到消息，则进行重试。这样来保证消息不丢失
         （在业务逻辑处理完后最后一步返回return consumeConcurrentlyStatus.CONSUME_SUCCESS）
    

4、**`RocketMQ实现延时消息？`**
    rocketMq支持延迟消息，message.setDelayTimeLevel(3)意思设置延迟级别3，就是延迟10S。5.0之前只支持1s到2h中间的几个时长，并且使用Timer定时器来实现延迟投递。
    5.0之后新增了基于时间轮实现的定时消息。它是一种高效的定时器算法，能处理大量的定时任务，并在O(1)时间内找到下一个执行的任务，因此提高消息投递性。

5、**`RocketMQ消息堆积怎么办？`**
    01、产生原因：消息堆积一般是因为客户端本地消费过程中，由于消耗耗时过长或消费并发度小等原因，导致消费能力不足，出现消息堆积。
    02、问题排查（可不答）：实践：消息订阅不一致（应用因特殊原因，将springCloudStream改为rocketMQ，修改配置上线后，出现消息堆积问题，经排查是两个东西一个配置了一个MQConsumerInner）
            导致rocketMQ不确定是否消费，就先堆积到broker中。
    03、如何解决：1、增加消费者数量，让更多消费实例消费这些消息。2、提升消费者消费速度：如果时消费慢的情况，可以考虑引入线程池、放入缓存或本地消息存储后直接返回成功，然后异步处理。
            3、降低生产者生产速度：如果生产可控的时候可以考虑 4、清理过期消息：过期消息，无法成功的消息，经过评估后，进行删除。 
            5、调整MQ配置参数：如消息消费模式、消息拉取间隔时间等 来优化消费效率。 6、增加topic队列数：如果一个topic的messageQueue比较少，可增加队列的方式提高消息处理并发度。
    
6、**`rocketMQ怎么实现消息分发？`**
    01、支持两种消费模式：广播模式、集群模式
        广播模式：当为此模式，每条消息都会推送给集群内的消费者，保证消息至少被消费一次。但是它并不会重投消费失败的消息，并且每一次重启都会从最新消息开始消费。
        集群模式：mq认为任意一条消息只需要集群内任意消费者处理即可，集群模式下只会被分发到一台机器上处理。
        
5、**`rocketMQ消息是推还是拉？`**
    分为两种，一种是推push，一种是拉pull（push是服务端主动推送给客户端，pull是客户端主动轮询拉取服务端数据）
    push优点是及时性好，但客户端没做好流控，服务端推送大量消息到客户端，就会导致客户端消息堆积或崩溃。
    pull优点就是一句自己消费能力进行消费，频繁拉取会给服务端造成压力，也存在消费不及时问题。
    01、pull在rocketMQ建议使用DefaultLitePullConsumer，并且提供subscribe和assign两种模式。需要注意的是，rocketMQ的push模式其实底层实现是基于pull实现的。
        里面是基于http长轮询实现的。push主要实现是在pullMessageProcessor的processRequest，在里面会创建一个轮询任务，逻辑在pullRequestHoldService的子线程。
        这个现场每隔一段时间（5秒或20秒），执行一次数据拉取（具体实现在checkColdDataPullRequest方法）

6、**`rocketMQ一定能实现削峰的效果嘛？`**
    削峰填谷就是高并发场景下，面对大量请求，用mq缓冲这些请求，将大量并发暂存到队列中，然后按照系统能处理的速度逐渐消费，避免系统崩溃。
    但是用了mq就能实现削峰填谷嘛？答：不一定，要看MQ的消费方式，有推和拉的两种模式，如果是推push模式，如果上游发送消息后，会立即推给消费者，如果数据量太大，
        客户端承担很大请求量，如果消费能力不满足，就会出现消息堆积，最终系统崩溃。所以，在削峰填谷时，推荐使用pull模式，自己控制消费速度，这样消息就是堆在broker上。

7、**`RocketMq高可用性？`**
  	通过broker主从机制实现高可用
  	消息生产的高可用：在创建topic时，把topic的多个message queue创建在多个broker组上，当一个broker组的master不可用时，生产者可以给其他broker上面继续发消息
  	消费消息的高可用：不能支持配置从master读还是slave读，当master不可用或者繁忙的时候，会自动切换到slave中读，保障了消息消费的高可用
  	消息存储结构： commitLog（存储消息的元数据）、ConsumerQueue（存储消息在CommitLog的索引）、indexFile(提供一种通过key或者时间区间查询消息的方法)
  	刷盘机制：同步刷盘、异步刷盘（可能会造成消息丢失）
  	主从复制：同步复制、异步复制（异步复制）
  	producer负载均衡： producer在发送消息时，默认轮询所有queue,消息发送到不同的queue上，queue分布在不同的broker上。
  	consumer负载均衡：默认的分配算法AllocateMessageQueueAveragely（每个consumer实例平均分配每个consume queue）
  	消息重试：
  		发送端重试
  		消费端重试：对于顺序消息，进行消息重试的时候，后续消息会被阻塞。这一块监控要做好，避免后续消息阻塞
  	重试队列和死信队列：
  		消息失败进入重试队列
  		失败后达到最大重试次数后，进入死信队列，以DLQ消费组命名	
    
    mysql继续写，明天记得同步上去
8、**`什么是脏读、不可重复读、幻读？事务隔离级别？为什么默认为RR？`**
    1、01、脏读：读到其他事务还没提交的数据。02、不可重复读：对某数据进行读取时，其他事务修改了数据，导致第二次读的时候数据不一致。
       03、幻读：事务做范围查询时，另一个事务插入或删除数据，导致范围查询结果条数不一致。
    所以，mysql定义了4中隔离级别来解决这些异常情况：读未提交、读已提交、可重复读、顺序执行。
    2、事务隔离级别：
        01：读未提交：最低的隔离级别，这种级别下，可以读到其他事务的数据，存在幻读、脏读、不可重复度的问题。
        02：读已提交：事务修改后，如果没提交，另外一个事务不能读取。防止了脏读发生。
        03：可重复性读：解决了不可重复读问题，同一事务中修改后数据跟修改前数据一致。但无法彻底解决幻读。
        04：可串行化：所有问题都能解决。性能极差。
    3、**为什么mysql默认使用RR隔离级别**
        01、首先mysql主从同步时，从服务是通过主服务器的binLog进行的，binLog主要支持三种格式：statement，row以及mixed。当为statement时，记录的是sql原文。
        02、如果我们使用read commit，两个事务，A事务删除数据，B事务新增数据，B事务比A事务先执行，由于是RC隔离级别，即使A事务删除在B事务后，B事务插入操作不会看到
            A事务的删除操作。所以会保留B事务的插入数据。
        03、这个时候binLog记录就会两条记录，因为B事务比A事务先执行，所以binLog记录的是插入操作，然后在删除操作。
        04、那么binLog同步到从节点时，它回放binlog时，就是先插后删，数据没了。
        05、为了避免这个问题发生，mysql默认使用RR级别，因为在RR级别中，更新数据时会加行级锁，还会增加GAP锁。
    4、**为什么默认RR，大厂要改成RC**
        答：虽然RR的隔离级别在一定程度上避免脏读、不可重复读和幻读问题，但是大厂都更愿意换成RC级别，从而提高并发度并降低死锁的概率。
        RR和RC的区别：01：一致性读（快照读）：RR和RC读取的时候都会使用一致性读，RC还支持半一致读
                    02：锁机制：mysql中的三种类型锁（记录锁，间隙锁，next-key锁），在RC中，只对索引增加记录锁，不会加间隙锁或其他。RR中为了解决幻读问题，会加间隙锁。
        主从同步：如果改为RC，那么binlog的格式一定不能时statement，可以选择row或者mixed。
        所以：大厂选择RC就是为了提高并发，减少死锁。对不可重复读和幻读利用其他手段保证，比如乐观锁，或者在代码层面。

9、**`InnoDB如何解决脏读、不可重复读和幻读？`**
    在innodb中，通过MVCC解决脏读和不可重复读，通过MVCC+间隙锁解决幻读。
    脏读的解决：在RC及以上读取时，innoDB获取最新的全局事务ID，这个ID表示当前时刻所有已提交事务的最新状态。确保事务只能看到在它开始之前已经提交的数据版本。
    不可重复度读的解决：通过MVCC来解决不可重复读的问题，在RR级别中，就在第一次读取的时候生产一个read view，后续所有快照读都使用同一个read view。
    幻读的解决：基于MVCC+间隙锁，某种程度上可以避免幻读的发生，但没办法避免。
        

        
        
    
    
        
