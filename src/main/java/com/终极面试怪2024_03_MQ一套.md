#MQ开始了哦
###先讲RocketMQ
1、**`RocketMQ事务消息如何实现？`**
    rocketMQ的事务消息通过TransactionListener接口实现。
    整个流程：01、先给Broker发送一条half半消息，half消息存储在broker端中，此时不会发送给消费者（标记为prepared状态）。 02、half消息发送给消息发送方（也就是生产者）
        03、生产收到half消息后提交本地事务，并发送commit或者rollback消息。 04、rocketMQ接收到反馈后，rollback就回滚该事物，提交就将消息还原成原始消息，传给消费者。
        04、消费者消费消息（如果消费失败，则会重试，直到最终一致性）
    问题点：01：如果生产者收到half消息后，broker一直收不到commit或者rollback怎么办？
        答：如果在规定时间内没收到，rocketMQ会向应用程序发送一条检查请求，看回调方法是否能收到该事务消息，如果应用程序还是在规定时间未响应，标记为unknow状态。标记unknow状态的消息，
            如果应用程序有结果，还可以向MQ发送commit或者rollback。但如果超过72小时，mq会自动回滚该事务消息。
        02：第一次发送half消息失败怎么办？答：重试
        03：为什么要用事务消息？答：本地事务执行完成后发送消息可能会发送失败，消费者无法处理，导致数据不一致。有了这个可以保证数据一致性。

2、**`RocketMQ如何保证消息顺序性？`**
    01：概念：它只支持在同一个队列内消息能做到有序性，不同queue中的消息是无序的。如果想要发送顺序消息，在send方法中，传入MessageQueueSelector。（在里面需要实现select方法，然后指定到那个messageQueue）。
    02：如何保证消费者有序消费：发送到同一队列后，消费者通过有序消费模式MessageListenerOrderly实现，这个实现里面通过三把锁保证顺序消费，
            第一把锁（确保消息只会投递到同一消费者）：保证同一个队列的有序消息可以被顺序消费，broker就只会把消息发到同一个消费者上，这时就需要加第一把锁，在consumeMessageOrderlyService初始化时，启动一个定时任务，
                尝试向broker为当前消费者客户端申请分布式锁。获取成功后后续消息就只发给这个消费者。
            第二把锁（对messageQueue加锁，确保只有一个线程处理这个消息队列）：消息拉取时，消费者会一次性拉取多条消息，放入ProcessQueue，然后提交到消费线程池。为保证顺序消费，所以一个队列只能
                一个线程处理队列消息。
            第三把锁（processQueue加锁确保重平衡过程中不会出现重复消费）：获取到第二把锁后，就可以从processQueue依次拉取一批消息处理，为保证消息不重复消费，需要对processQueue加锁。
    03：为什么需要第三把锁？ 答：为了重平衡，如果新增消费者，发生重平衡，比如队列原来属于客户端A消费，现在重新分配给客户端B去消费，可能存在一部分数据重复消费，所以对processQueue加锁。
    04：顺序消费存在的问题：这三把锁的方式可能会降低系统吞吐量，而且出现消息阻塞的话，可能会达到系统瓶颈。

3、
