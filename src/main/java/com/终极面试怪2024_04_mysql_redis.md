#数据库和redis开始了哦
###先讲mysql
1、**`innoDB和myISAM区别？`**
    01、innoDB支持事务，myISAM不支持。 02、InnoDB是聚集索引，myIASM是非聚集索引。 03、InnoDB支持外键，my不支持。 
    04、InnoDB最小粒度是行锁，my最小粒度是表锁 05、innoDB在5.6之前不支持fulltext类型索引 06、inno不保存行数，my会保存 
    07、自增长字段，inno必须包含只有该字段索引，my可以建联合索引。 08、删除表inno是一行一行删，my是直接重建表。

2、**`char和varchar区别？`**
    char是定长数据类型，长度固定并且在存储时会自动在结尾添加空格来将字符串填满指定长度。
    varchar是一种可变的数据类型，只存储实际的字符串内容，不填充空格，存储短字符串时，可节省空间。
    优缺点：varchar优点：可变长的字符串类型，具有收缩性，兼容性更好。
           varchar缺点：01、因为可变，在缩短和扩张时，因为mysql之间是连续存放在文件地址中，可能会造成也分裂和页合并的问题。02、还可能产生内存碎片
                03、varchar额外存储了1到2个字节的长度信息。
        char优点：定长字符串，减少内存碎片，无需额外磁盘空间存储长度信息。 char缺点：会丢失列末尾的空格信息。设计不规范时，造成空间浪费。

3、**`mysql5.X和8.0的区别？`**
    01、性能（8.0速度比5/7快2倍，从读/写工作负载，IO密集型工作负载等）02、隐藏索引（8.0后，索引可以被隐藏和现实。隐藏时不会被优化器使用，可以利用这个特性来走性能调试）
    03、取消查询缓存（为了提高查询性能）04、select for update支持no wait（加了nowait后，如果发现竞争关系，会抛错）

4、**`为什么不建议使用多表join？`**
    不建议使用，是因为join效率低，mysql是使用了嵌套循环的方式实现关联查询的，简单说就是两层循环，一张做外循环，一张内循环。
    具体实现的算法是simple nested loop（两两对比，复杂度N*M），block nested loop(引入一个Buffer，基于内存查)， 
            index nested loop（有索引的话，用索引，复杂度N*logM）。这三种效率都不是特别高。
    如何解决：01、查出来后，在代码中自己处理相应关系后，二次查询，在内存中关联。 02、数据冗余，将重要数据冗余，避免关联 
            03、宽表：基于join关系，做一张大宽表，同步到ES

5、**`一条查询sql的执行过程？`**
    分下面几个步骤：1、使用**连接器**,与mysql建立连接，并校验权限。 2、8.0之前会检查是否开启查询缓存，如果sql相同，就返回缓存给客户端。
        3、由**解析器**进行语法分析和语义分析，并生成解析树，然后由**预处理器**检查解析数的合法性。 4、然后**优化器**生成执行计划，看是否优化sql。
        5、**执行器**执行sql语句，然后返回结果，开始查询缓存则缓存。

6、**`mysql中行格式？`**
    01、compact是5.0前的默认格式，除字段值外还记录变长字段长度列表和头信息（null值列表）。02、redundant（很少用）
    03、dynamic：5.7后引入，compact升级版，结构大致相同。 04：compressed（5.1的新特性，可以对存储数据压缩，减少磁盘占用空间）

7、**`一条更新sql的执行过程？`**
    一次更新操作，设计到bufferPool、binlog、undoLog、redoLog以及物理磁盘，完成的操作如下:
    01、在buffer pool中读取数据：更新前先查buffer pool是否有该记录。没有就从磁盘读取改页到buffer pool中。
    02、记录undoLog：用undoLog记录修改前数据。UndoLog是用来保证事务原子性和一致性的一种机制，通常用于事务发生回滚，将值回滚到修改前的状态。
            它最开始写到内存中，然后由一个后台线程定时刷新到磁盘中。
    03、在buffer pool中更新：执行update语句时，先更新bufferPool数据，不直接写入磁盘。然后将修改的这个数据页设置为脏页。
    04、记录redoLog buffer：在bufferPool修改的同时，会把修改操作写入redoLog buffer中。
    05、提交事务：提交时，将redoLog写入磁盘，保证事务的持久性。
    06、写入磁盘：提价后，先把bufferPool的脏页写入磁盘，保证数据的持久性。写入先是写到pageCache中，然后后台线程异步写入磁盘，可能会存在延迟。
    07、记录binlog：提交时，也会将事务信息记录到binlog中。binlog是用来实现主从复制的机制，里面记录信息比较全（包括事务开始时间，数据库名，表名，事务ID等）
    （注意：binglog和redolog，都是通过2阶段提交保证一致性）

8、**`什么是脏读、不可重复读、幻读？事务隔离级别？为什么默认为RR？`**
    1、01、脏读：读到其他事务还没提交的数据。02、不可重复读：对某数据进行读取时，其他事务修改了数据，导致第二次读的时候数据不一致。
        03、幻读：事务做范围查询时，另一个事务插入或删除数据，导致范围查询结果条数不一致。
        所以，mysql定义了4中隔离级别来解决这些异常情况：读未提交、读已提交、可重复读、顺序执行。
    2、事务隔离级别：
        01：读未提交：最低的隔离级别，这种级别下，可以读到其他事务的数据，存在幻读、脏读、不可重复度的问题。
        02：读已提交：事务修改后，如果没提交，另外一个事务不能读取。防止了脏读发生。
        03：可重复性读：解决了不可重复读问题，同一事务中修改后数据跟修改前数据一致。但无法彻底解决幻读。
        04：可串行化：所有问题都能解决。性能极差。
    3、**为什么mysql默认使用RR隔离级别**
        01、首先mysql主从同步时，从服务是通过主服务器的binLog进行的，binLog主要支持三种格式：statement，row以及mixed。当为statement时，记录的是sql原文。
        02、如果我们使用read commit，两个事务，A事务删除数据，B事务新增数据，B事务比A事务先执行，由于是RC隔离级别，即使A事务删除在B事务后，B事务插入操作不会看到
        A事务的删除操作。所以会保留B事务的插入数据。
        03、这个时候binLog记录就会两条记录，因为B事务比A事务先执行，所以binLog记录的是插入操作，然后在删除操作。
        04、那么binLog同步到从节点时，它回放binlog时，就是先插后删，数据没了。
        05、为了避免这个问题发生，mysql默认使用RR级别，因为在RR级别中，更新数据时会加行级锁，还会增加GAP锁。
    4、**为什么默认RR，大厂要改成RC**
        答：虽然RR的隔离级别在一定程度上避免脏读、不可重复读和幻读问题，但是大厂都更愿意换成RC级别，从而提高并发度并降低死锁的概率。
        RR和RC的区别：01：一致性读（快照读）：RR和RC读取的时候都会使用一致性读，RC还支持半一致读
        02：锁机制：mysql中的三种类型锁（记录锁，间隙锁，next-key锁），在RC中，只对索引增加记录锁，不会加间隙锁或其他。RR中为了解决幻读问题，会加间隙锁。
        主从同步：如果改为RC，那么binlog的格式一定不能时statement，可以选择row或者mixed。
        所以：大厂选择RC就是为了提高并发，减少死锁。对不可重复读和幻读利用其他手段保证，比如乐观锁，或者在代码层面。

9、**`InnoDB如何解决脏读、不可重复读和幻读？`**
    在innodb中，通过MVCC解决脏读和不可重复读，通过MVCC+间隙锁解决幻读。
    脏读的解决：在RC及以上读取时，innoDB获取最新的全局事务ID，这个ID表示当前时刻所有已提交事务的最新状态。确保事务只能看到在它开始之前已经提交的数据版本。
    不可重复度读的解决：通过MVCC来解决不可重复读的问题，在RR级别中，就在第一次读取的时候生产一个read view，后续所有快照读都使用同一个read view。
    幻读的解决：基于MVCC+间隙锁，某种程度上可以避免幻读的发生，但没办法避免。
    

    
    
    