1、**`jvm一次完成的GC流程`**
    01：对象创建时，根据大小决定分配老年代还是新生代（-XX:PretenureSizeThreshold来控制大小）。02：eden区创建对象时，内存不够就出发yongGC。
    03：年轻代采用标记复制算法，标记、复制、清除这三步骤，清理后eden和survivor中复制到另一个survivor区 04: 最后survivor空间不够或者gc次数
        大于15次的进入老年代，如果老年代担保失败，进行fullGC，一般使用cms或者G1，他们采用的三色标记法。

2、**`什么是跨代引用，有什么问题？`**
    jvm跨代引用指在堆内存不同代之中存在引用关系，比如新生代引用老年代，老年代引用新生代。
    有什么问题？在youngGC的时候发现对象处于老年代，jvm中断路径，如果A的引用在老年代，这个时候发生跨代引用。两种方法：01：在youngGC的时候，gcroot扫描到老年代后
        不中断，继续扫描，把所有在年轻代的对象标记上。02：在youngGC时，把老年代对象作为GCRoot，扫描。 两种方法缺点：成本太高了，需要扫描整个老年代，还需要做标记。
    所以在老年代中引用新生代的跨代问题中，引入了remembered Set，这个主要跟踪老年代在新生代的引用关系，然后扫描的时候直接扫描remembered Set即可。

3、**`什么是safepoint，有啥用？`**
    安全点，就是代码执行过程中得一些特殊配置，当线程执行到这个位置时，被认为处于安全状态，有需要的话，可以在这里暂停，这里暂停是安全的

    